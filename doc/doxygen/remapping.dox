
/*!
\page conservativeremapping Conservative remapping

At the basis of many CFD numerical schemes is the fact that physical quantities such as density, momentum or energy obey some balance laws that should be preserved at the discrete level on every cell. This property is critical for example to accurately capture shockwaves. To comply with this constraint, a remapping of the field \f$ \phi \f$ from the source mesh \f$ S \f$ to the target mesh \f$ T \f$ should preserve the integral of \f$ \phi \f$ on any domain. At the discrete level, for any target cell \f$ T_i \f$, one would like the following equality to be true 

\f[
\int_{T_i} \phi = \sum_{S_j\cap T_i \neq \emptyset} \int_{T_i\cap S_j} \phi. 
\f]
For fields with polynomial representation on each cell, the components of the discretised field  \f$ \phi_s \f$ on the receiving side can be expressed as linear combinations of the components of the discretised field \f$ \phi_t \f$ on the target side, id est in terms of a matrix-vector product : 

\f[
 \phi_t=W.\phi_s.
\f] 

The coefficients of the linear remapping matrix \f$ W \f$ depends only on the source and target meshes and on the representation chosen for the fields: P0, P1, P1d etc... For the moment it is only possible to remap fields with P0 representations.

\section P0-P0 cell-cell (P0->P0) conservative remaping

In the case where the field values are constant on each cell, the coefficients of the linear remapping matrix \f$ W \f$ are given by the formula

\f[
 W_{ij}=\frac{Vol(T_i\cap S_j)}{Vol(T_i)}. 
\f] 

Therefore one needs to compute intersection between source and target cells to obtain the linear remapping matrix which will generally be a sparse matrix.  The Intersection computation proceeds in two steps: 
- first a filtering process reduces the number of pairs of elements for which the calculation must be carried out by eliminating pairs that do not intersect through a comparison of their bounding boxes
-  then, the volume or area of the intersection is calculated for the remaining pairs by an algorithm which is specific to each case (see \ref interpolation2D, \ref interpolation3Dsurf or \ref interpolation3D). 

\subsection interpolation2D  Special features of 2D  intersections

When remapping two dimensional fields, areas of intersection between polygonal cells are to be computed. Two algorithms are available:
- Triangle: decompose each cells into triangles and computes triangle-triangle intersection by determining segment crossings and node inclusions. This algorithm is the fastest if both meshes are made of triangular cells.
- Convex: presume that both meshes are made of convex cells, and performs a direct computation of the intersection nodes between two cells through a sweep line algorithm (see  F. Preparata and M. Shamos, 1985 in \ref references).
For the moment, it is only possible to remap two dimensional fields on meshes with mixed triangular and quadrangular elements.
The following options are available for the 2D intersection computations:

 * <TABLE BORDER=1 >
 * <TR><TD>Option</TD><TD>Description</TD><TD> Admitted values</TD><TD>Default</TD></TR>
 * <TR><TD> Intersection_type</TD><TD>Specifies the algorithm to be used in the computation of the cell-cell intersections</TD><TD>  Triangle, Convex</TD><TD> Triangle </TD></TR>
 * <TR><TD> Precision </TD><TD>Accuracy of the computations is precision times the characteristic size of the meshes </TD><TD>  positive real numbers</TD><TD> 1.0E-12 </TD></TR>
 * <TR><TD>PrintLevel </TD><TD>Level of verboseness during the computations </TD><TD> 0, 1, 2, 3 </TD><TD>0 </TD></TR>
 *</TABLE>

\subsection interpolation3Dsurf Special features of 3D surface intersections 

When remapping a three dimensional surfaces, one should give a meaning to the area of intersection between two three-dimensional non coplanar polygons. A projection phase is thus necessary to have both polygons on the same plane. Care must be taken when defining this projection to avoid non conservative remappings. After the projection step, the source and target cells lie in the same plane and the same algorithms as for 2D remapping can be employed.
For the moment, it is only possible to remap fields on  three dimension surfacic meshes with mixed triangular and quadrangular elements.
Similar options as for the 2D remapping are available, plus some additional options specific to 3D surface remapping:

 * <TABLE BORDER=1 >
 * <TR><TD>Option</TD><TD>Description</TD><TD> Admitted values</TD><TD>Default</TD></TR>
 * <TR><TD> MedianPlane </TD><TD>Position of the median plane where both cells will be projected </TD><TD>  Triangle, Convex</TD><TD> Triangle </TD></TR>
 * <TR><TD> Precision </TD><TD>Accuracy of the computations is precision times the characteristic size of the meshes </TD><TD>  real numbers between 0 and 1 </TD><TD> 0.5 </TD></TR>
 * <TR><TD>DoRotate </TD><TD>Performs a rotation of the coordinate system such that the median plane is the Oxy plane </TD><TD>  boolean true or false </TD><TD> true </TD></TR>
 *</TABLE>

Note that choosing the Triangle Intersection_type necessarily set the DoRotate option to true.

\subsection interpolation3D Special features of 3D volumes intersections
When remapping three dimensional fields, volumes of intersection between polyhedral cells are to be computed. We use the method of Jeffrey Grandy, 1999 (see \ref references) to intersect arbitrary polyhedra. The basic algorithm computes the intersection of a tetrahedron with an arbitrary (possibly non convex) polyhedron. Using splitting techniques, it is possible to transform the problem of computing the intersection between two general polyhedra into several tetrahedron-polyhedron intersection calculations. For the moment it is only possible to remap fields on meshes having mixed tetrahedral and hexahedral cells. When using a mesh with hexahedral cells, several splitting techniques may be employed depending mainly on wether the faces are planar or not. The following options are available for the splitting:

 * <TABLE BORDER=1 >
 * <TR><TD>Option</TD><TD>Description</TD><TD> Admitted values</TD><TD>Default</TD></TR>
 * <TR><TD> SplittingPolicy </TD><TD> Way in which the hexahedra are split into tetrahedra </TD><TD> PLANAR_FACE_5,  PLANAR_FACE_6, GENERAL_24, GENERAL_48</TD><TD> GENERAL_48 </TD></TR>
 * <TR><TD>PrintLevel </TD><TD>Level of verboseness during the computations </TD><TD> 1, 2, 3, 4, 5 </TD><TD>0 </TD></TR>
 * </TABLE>

Note that a SplittingPolicy values starting with the word "PLANAR" presume that each face is to be considered planar, while the SplittingPolicy values starting with the word GENERAL does not. The integer at the end gives the number of tetrahedra that result from the split.
 Consider an hexahedron with with planar faces and nodes numbered according to the following picture:
\verbatim
   
              7 ------ 6
             /|       /|
            / |      / |
           3 ------ 2  |
           |  |     |  |
           |  |     |  |
           |  4-----|- 5
           | /      | /
           0 ------ 1
\endverbatim
The use of the SPLIT_NODES_5 splitting policy would lead to a 5 tetrahedra decomposition as follows :
\verbatim
	0, 1, 5, 2
	0, 4, 5, 7
	0, 3, 7, 2
	5, 6, 7, 2
	0, 2, 5, 7
\endverbatim
The use of the SPLIT_NODES_6 splitting policy would lead to a 6 tetrahedra decomposition as follows :
\verbatim
	0, 1, 5, 6
	0, 2, 1, 6
	0, 5, 4, 6
	0, 4, 7, 6
	0, 3, 2, 6
	0, 7, 3, 6
\endverbatim

*/