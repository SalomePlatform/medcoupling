/*!
\page medcouplingcppexamples MEDCoupling C++ examples


\anchor cpp_mcfielddouble_WriteVTK
<br><h2> Writting fields in a VTK file </h2>

In this example we 
- create an 2D mesh and 3 fields on it,
- use 
\ref ParaMEDMEM::MEDCouplingFieldDouble::WriteVTK "WriteVTK()"
to write all the fields and the mesh to a VTK file.

\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_WriteVTK_1



\anchor cpp_mcfielddouble_MaxFields
<br><h2> Getting maximal and minimal fields </h2>

In this example we 
- create two fields with two tuples per two components,
- use 
\ref ParaMEDMEM::MEDCouplingFieldDouble::MaxFields "MaxFields()"
to get a field holding maximal values of the two fields.
- use 
\ref ParaMEDMEM::MEDCouplingFieldDouble::MinFields "MinFields()"
to get a field holding minimal values of the two fields.

\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_MaxFields_1


\anchor cpp_mcfielddouble_MergeFields
<br><h2> Concatenating fields</h2>

In this example we 
- create an 1D mesh and a field on it,
- make a deep copy of the mesh and the field,
- translate the mesh and the field,
- use two variants of
\ref ParaMEDMEM::MEDCouplingFieldDouble::MergeFields "MergeFields()"
to create one field from the two by concatenating them and their meshes.

\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_MergeFields_1
The result field is twice "longer" than \b field1.



\anchor cpp_mcfielddouble_substractInPlaceDM
<br><h2> Subtracting field on different meshs </h2>

We make two meshes in 1D space with no cells and 4 nodes. Nodes #0 and #2 are swapped
in the two meshes.<br>
And we make two fields on these meshes, so that fields values to equal to node
coordinates of the underlying meshes.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_substractInPlaceDM_1
We are going to subtract \b field2 from \b field1, though they are on
different meshes.
\ref ParaMEDMEM::MEDCouplingFieldDouble::substractInPlaceDM "substractInPlaceDM()"
allows us doing this. We use a mesh comparison level \b levOfCheck = 10 that allows
subtracting fields on meshes with different node arrays.<br>
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_substractInPlaceDM_2
After applying 
\ref ParaMEDMEM::MEDCouplingFieldDouble::substractInPlaceDM "substractInPlaceDM()"
the both fields lie on \b mesh2. As
\ref ParaMEDMEM::MEDCouplingFieldDouble::substractInPlaceDM "substractInPlaceDM()"
permutes values of \b field1 before value subtraction, and thus \b field1 becomes
equal to \b feild2, hence their subtraction results in a zero field.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_substractInPlaceDM_3



\anchor cpp_mcfielddouble_changeUnderlyingMesh
<br><h2> Changing the underlying mesh </h2>

We make two meshes in 1D space with no cells and 4 nodes. Nodes #0 and #2 are swapped
in the two meshes.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_changeUnderlyingMesh_1
We are going to use
\ref ParaMEDMEM::MEDCouplingFieldDouble::changeUnderlyingMesh "changeUnderlyingMesh()"
to set \b mesh2 instead of \b mesh1 as a support of a field. <br>
We use
\ref ParaMEDMEM::MEDCouplingMesh::fillFromAnalytic "fillFromAnalytic()"
to make a field on nodes of \b mesh1, so that its values to equal to node coordinates.
Then we use 
\ref ParaMEDMEM::MEDCouplingFieldDouble::changeUnderlyingMesh "changeUnderlyingMesh()"
to change the underlying mesh of the \b field.
(We use a mesh comparison level \b levOfCheck = 10 that allows substituting meshes with
different node arrays.) As a result, we expect that values of the \b field are also
permuted same as nodes of the two meshes, and thus its values become equal to the
array \b coords2.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_changeUnderlyingMesh_2


\anchor cpp_mcfielddouble_applyFunc_same_nb_comp
<br><h2> Changing a field using a formular </h2>

We create a 2D vector field with 2 tuples and we want to transform this
field using a formular using 
\ref ParaMEDMEM::MEDCouplingFieldDouble::applyFunc(const char *func) "applyFunc()".
The formular \b func is applied each atomic value of the \b field. We want to change
the \b field as follows. (In \b func, we use the variable "v" to refer to an atomic field value). 
- Component #0 = component #0 (remains the same); hence "IVec * v" in \b func.
- Component #1 = component #1 ^ 2; hence "JVec * v*v".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc_same_nb_comp_1
Now we ascertain that the result field is as we expect.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc_same_nb_comp_2



\anchor cpp_mcfielddouble_applyFunc3
<br><h2> Changing a field using a formular </h2>

We create a 2D vector field with 2 values (vectors) and then we transform this
field into a 3D vector field by applying a formular to values of the 2D field
using 
\ref ParaMEDMEM::MEDCouplingFieldDouble::applyFunc3() "applyFunc3()".
The formular \b func is applied to components of each vector of the \b field. We want
the \b field to have 3 components computed as follows. (In \b func, we refer to the
first component of a field value using the variable "a", and to the second component, using
the variable "b", as we define it by \b varNamesVec). 
- Component #0 = the second vector component; hence "IVec * b" in \b func.
- Component #1 = the first vector component; hence "JVec * a".
- Component #2 = a vector magnitude; hence "KVec * sqrt( a*a + b*b )".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc3_1
Now we ascertain that the result field is as we expect. We check the second vector of
the \b field.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc3_2



\anchor cpp_mcfielddouble_applyFunc2
<br><h2> Changing a field using a formular </h2>

We create a 2D vector field with 2 values (vectors) and then we transform this
field into a 3D vector field by applying a formular to values of the 2D field
using 
\ref ParaMEDMEM::MEDCouplingFieldDouble::applyFunc2(int nbOfComp, const char *func) "applyFunc2()".
Note that we set component info the \b array ("a" and "b" ) which will be used to refer to
corresponding components within a function.
The formular \b func is applied to components of each vector of the \b field. We want
the \b field to have 3 components computed as follows. (In \b func, we refer to the
first component of a field value using the variable "a", and to the second component, using
the variable "b"). 
- Component #0 = the second vector component; hence "IVec * b" in \b func.
- Component #1 = the first vector component; hence "JVec * a".
- Component #2 = a vector magnitude; hence "KVec * sqrt( a*a + b*b )".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc2_1
Now we ascertain that the result field is as we expect. We check the second vector of
the \b field.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc2_2



\anchor cpp_mcfielddouble_applyFunc
<br><h2> Changing a field using a formular </h2>

We create a 2D vector field with 2 values (vectors) and then we transform this
field into a 3D vector field by applying a formular to values of the 2D field
using 
\ref ParaMEDMEM::MEDCouplingFieldDouble::applyFunc(int nbOfComp, const char *func) "applyFunc()".
The formular \b func is applied to components of each vector of the \b field. We want
the \b field to have 3 components computed as follows. (In \b func, we refer to the
first component of a field value using the variable "a", and to the second component, using
the variable "b"). 
- Component #0 = the second vector component; hence "IVec * b" in \b func.
- Component #1 = the first vector component; hence "JVec * a".
- Component #2 = a vector magnitude; hence "KVec * sqrt( a*a + b*b )".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc_1
Now we ascertain that the result field is as we expect. We check the second vector of
the \b field.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc_2



\anchor cpp_mcfielddouble_applyFunc_val
<br><h2> Filling a field with a value</h2>

We want to transform a 2D vector field to a 3D vector field so that all values to be
equal to a certain value. First, we create the 2D mesh and the vector field on it.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc_val_1
Finally we use
\ref ParaMEDMEM::MEDCouplingFieldDouble::applyFunc(int nbOfComp, double val) "applyFunc()"
to change the number of components and all field values.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_applyFunc_val_2
As a result, number of tuples in the field equals to the number of cells in the mesh,
and number of components becomes equal to 3 as required.


\anchor cpp_mcfielddouble_fillFromAnalytic3
<br><h2> Filling a field using a formular </h2>

First, we create a 2D Cartesian mesh constituted by 2 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_fillFromAnalytic3_1
Now we create a field on cells and use
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic2 "fillFromAnalytic2()"
to fill it
with values computed using a formular \b func. This formular is applied to coordinates of
each point (barycenter) for which the field value is computed. We want the \b field
to have 3 components computed as follows. (In \b func, we refer to the
first component of a point using the variable "a", and to the second component, using
the variable "b").
- Component #0 = the second coordinate of the point; hence "IVec * b" in \b func.
- Component #1 = the first coordinate of the point; hence "JVec * a".
- Component #2 = distance between the point and SC origin (0.,0.); hence 
"KVec * sqrt( a*a + b*b )".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_fillFromAnalytic3_2
Now we ascertain that the result field is as we expect. We check the second tuple of
the \b field. We get barycenter of the cell #1 and checks that values of the second
tuple are computed as we want.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_fillFromAnalytic3_3



\anchor cpp_mcfielddouble_fillFromAnalytic2
<br><h2> Filling a field using a formular </h2>

First, we create a 2D Cartesian mesh constituted by 2 cells.
Note that we set names to coordinates arrays ("a" and "b" ) which will be used to refer to
corresponding coordinates within a function.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_fillFromAnalytic2_1
Now we create a field on cells and use
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic2 "fillFromAnalytic2()"
to fill it
with values computed using a formular \b func. This formular is applied to coordinates of
each point (barycenter) for which the field value is computed. We want the \b field
to have 3 components computed as follows. (In \b func, we refer to the
first component of a point using the variable "a", and to the second component, using
the variable "b").
- Component #0 = the second coordinate of the point; hence "IVec * b" in \b func.
- Component #1 = the first coordinate of the point; hence "JVec * a".
- Component #2 = distance between the point and SC origin (0.,0.); hence 
"KVec * sqrt( a*a + b*b )".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_fillFromAnalytic2_2
Now we ascertain that the result field is as we expect. We check the second tuple of
the \b field. We get barycenter of the cell #1 and checks that values of the second
tuple are computed as we want.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_fillFromAnalytic2_3


\anchor cpp_mcfielddouble_fillFromAnalytic
<br><h2> Filling a field using a formular </h2>

First, we create a 2D Cartesian mesh constituted by 2 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_fillFromAnalytic_1
Now we create a field on cells and use
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic(int nbOfComp, const char *func) "fillFromAnalytic()"
to fill it
with values computed using a formular \b func. This formular is applied to coordinates of
each point (barycenter) for which the field value is computed. We want the \b field to have
 3 components computed as follows. (In \b func, we refer to the
first component of a point using the variable "a", and to the second component, using
the variable "b").
- Component #0 = the second coordinate of the point; hence "IVec * b" in \b func.
- Component #1 = the first coordinate of the point; hence "JVec * a".
- Component #2 = distance between the point and SC origin (0.,0.); hence 
"KVec * sqrt( a*a + b*b )".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_fillFromAnalytic_2
Now we ascertain that the result field is as we expect. We check the second tuple of
the \b field. We get barycenter of the cell #1 to check that values of the second
tuple (#1) are computed as we want.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_fillFromAnalytic_3


\anchor cpp_mcfielddouble_getValueOn_time
<br><h2> Getting a field value at some point at certain time</h2>

First, we create a supporting structured mesh. We create a 2x2 Cartesian mesh
constituted by 4 cells. 
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_getValueOn_time_1
Then we create a scalar field on cells, whose values vary linearly in time.
We set all field values at a start time to be equal 10.0 using
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic "fillFromAnalytic()".
And we set all field values at an end time to be equal 20.0 by doubling the start
time array.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_getValueOn_time_2
Now, we want to get a field value at a point [0,0] at a middle time between the start
and end times. We expect the returned value to be equal to an average of 10. and 20.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_getValueOn_time_3


\anchor cpp_mcfielddouble_getValueOnMulti
<br><h2> Getting field values at some points</h2>

First, we create a supporting structured mesh. We create a 2x2 Cartesian mesh
constituted by 4 cells. Then we create a scalar field on cells using
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic "fillFromAnalytic()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_getValueOnMulti_1
Now, we want to retrieve all field values using 
\ref ParaMEDMEM::MEDCouplingFieldDouble::getValueOnMulti "getValueOnMulti()".
The field values relate to cells, hence we will use cell barycenters as a parameter of
\ref ParaMEDMEM::MEDCouplingFieldDouble::getValueOnMulti "getValueOnMulti()".
We expect that the double array returned 
\ref ParaMEDMEM::MEDCouplingFieldDouble::getValueOnMulti "getValueOnMulti()"
is equal to that stored by \b field.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_getValueOnMulti_2



\anchor cpp_mcfielddouble_getValueOn
<br><h2> Getting a field value at a point</h2>

First, we create a supporting structured mesh. We create a 2x2 Cartesian mesh
constituted by 4 cells. Then we create a scalar field on cells using
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic "fillFromAnalytic()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_getValueOn_1
Now, we want to retrieve all field values using 
\ref ParaMEDMEM::MEDCouplingFieldDouble::getValueOn "getValueOn()".
The field values relate to cells, hence we will use cell barycenters to get a field
value at each cell.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_getValueOn_2
We collected all values returned by 
\ref ParaMEDMEM::MEDCouplingFieldDouble::getValueOn "getValueOn()" in an array, so
that we can ascertain that the array of returned values is same as that stored by \b
field. 



\anchor cpp_mcfielddouble_getValueOnPos
<br><h2> Getting a value of field lying on a structured mesh</h2>

First, we create a supporting structured mesh. We create a 2x2 Cartesian mesh
constituted by 4 cells. Then we create a scalar field on cells using
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic "fillFromAnalytic()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_getValueOnPos_1
Now, we retrieve a field value relating to the cell #3 (this cell has a structured indexed
(1,1)). For that we use
\ref ParaMEDMEM::MEDCouplingFieldDouble::getValueOnPos "getValueOnPos()" where we
pass the structured indexed of the cell: 1,1,-1 (the last index is meaningless as the
mesh is 2D).
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_getValueOnPos_2
After all we ascertain that the returned value corresponds to the formular used for
the field creation. Namely that the value equals to the sum of components of
barycenter of cell #3.



\anchor cpp_mcfielddouble_renumberNodes
<br><h2> Permuting a field on nodes</h2>

First, we create a supporting 2D mesh constituted by 4 cells. We create a 2x2
Cartesian mesh and then convert it to an unstructured one, since the Cartesian mesh
is not suitable for
\ref ParaMEDMEM::MEDCouplingFieldDouble::renumberNodes "renumberNodes()" as its
 nature does not imply node renumbering.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_renumberNodes_1
Then we create a field on nodes using
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic "fillFromAnalytic()", 
such that its values to coincide with coordinates of field location points that are
 nodes in our case (as our field is \ref ParaMEDMEM::ON_NODES "ON_NODES").
At last we ascertain that field values are equal to node coordinates.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_renumberNodes_2
Now, we are going to reverse order of nodes using
\ref ParaMEDMEM::MEDCouplingFieldDouble::renumberNodes "renumberNodes()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_renumberNodes_3
As a result, the underlying mesh of \b field is changed and its nodes are also
 renumbered. 
And the field values are still equal to node coordinates of the renumbered \b mesh2.



\anchor cpp_mcfielddouble_renumberCells
<br><h2> Permuting a field on cells</h2>

First, we create a supporting 2D mesh constituted by 4 cells. We create a 2x2
Cartesian mesh and then convert it to an unstructured one, since the Cartesian mesh
is not suitable for
\ref ParaMEDMEM::MEDCouplingFieldDouble::renumberCells "renumberCells()" as its
 nature does not imply cell renumbering.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_renumberCells_1
Then we create a field on cells using
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic "fillFromAnalytic()", 
such that its values to coincide with coordinates of field location points that are
 cell barycenters in our case (as our field is \ref ParaMEDMEM::ON_CELLS "ON_CELLS").
At last we ascertain that field values are equal to cell barycenters.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_renumberCells_2
Now, we are going to reverse order of cells using
\ref ParaMEDMEM::MEDCouplingFieldDouble::renumberCells "renumberCells()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_renumberCells_3
As a result, the underlying mesh of \b field is changed and its cells are also
 renumbered. 
And the field values are still equal to cell barycenters of the renumbered \b mesh2.



\anchor cpp_mcfielddouble_buildNewTimeReprFromThis
<br><h2> Getting a field copy with different time discretization </h2>

First, we create a supporting 2D mesh and a field on it got using
\ref ParaMEDMEM::MEDCouplingFieldDouble::fillFromAnalytic "fillFromAnalytic()".
\ref MEDCouplingTemporalDisc "Time discretization" of this field is 
\ref ParaMEDMEM::ONE_TIME "ONE_TIME".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_buildNewTimeReprFromThis_1
Now we use
\ref ParaMEDMEM::MEDCouplingFieldDouble::buildNewTimeReprFromThis "buildNewTimeReprFromThis()"
to get a copy of \b field1 whose time discretization is 
\ref ParaMEDMEM::NO_TIME "NO_TIME".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingFieldDouble_buildNewTimeReprFromThis_2


\anchor cpp_mcmesh_fillFromAnalytic3
<br><h2> Creating a field using a formular </h2>

First, we create a 2D Cartesian mesh constituted by 2 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingMesh_fillFromAnalytic3_1
Now we use
\ref ParaMEDMEM::MEDCouplingMesh::fillFromAnalytic3 "fillFromAnalytic3()"
to get a \ref ParaMEDMEM::MEDCouplingFieldDouble "MEDCouplingFieldDouble" on cells filled
with values computed using a formular \b func. This formular is applied to coordinates of
each point (barycenter) for which the field value is computed. We want to get the
field on cells, with 3 components computed as follows. (In \b func, we refer to the
first component of a point using the variable "a", and to the second component, using
the variable "b").
- Component #0 = the second coordinate of the point; hence "IVec * b" in \b func.
- Component #1 = the first coordinate of the point; hence "JVec * a".
- Component #2 = distance between the point and SC origin (0.,0.); hence 
"KVec * sqrt( a*a + b*b )".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingMesh_fillFromAnalytic3_2
Now we ascertain that the result field is as we expect. We check the second tuple of
the \b field. We get barycenter of the cell #1 and checks that values of the second
tuple are computed as we want.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingMesh_fillFromAnalytic3_3



\anchor cpp_mcmesh_fillFromAnalytic2
<br><h2> Creating a field using a formular </h2>

First, we create a 2D Cartesian mesh constituted by 2 cells.
Note that we set names to coordinates arrays ("a" and "b" ) which will be used to refer to
corresponding coordinates within a function.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingMesh_fillFromAnalytic2_1
Now we use
\ref ParaMEDMEM::MEDCouplingMesh::fillFromAnalytic2 "fillFromAnalytic2()"
to get a \ref ParaMEDMEM::MEDCouplingFieldDouble "MEDCouplingFieldDouble" on cells filled
with values computed using a formular \b func. This formular is applied to coordinates of
each point (barycenter) for which the field value is computed. We want to get the
field on cells, with 3 components computed as follows. (In \b func, we refer to the
first component of a point using the variable "a", and to the second component, using
the variable "b").
- Component #0 = the second coordinate of the point; hence "IVec * b" in \b func.
- Component #1 = the first coordinate of the point; hence "JVec * a".
- Component #2 = distance between the point and SC origin (0.,0.); hence 
"KVec * sqrt( a*a + b*b )".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingMesh_fillFromAnalytic2_2
Now we ascertain that the result field is as we expect. We check the second tuple of
the \b field. We get barycenter of the cell #1 and checks that values of the second
tuple are computed as we want.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingMesh_fillFromAnalytic2_3


\anchor cpp_mcmesh_fillFromAnalytic
<br><h2> Creating a field using a formular </h2>

First, we create a 2D Cartesian mesh constituted by 2 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingMesh_fillFromAnalytic_1
Now we use
\ref ParaMEDMEM::MEDCouplingMesh::fillFromAnalytic "fillFromAnalytic()"
to get a \ref ParaMEDMEM::MEDCouplingFieldDouble "MEDCouplingFieldDouble" on cells filled 
with values computed using a formular \b func. This formular is applied to coordinates of
each point (barycenter) for which the field value is computed. We want to get the
field on cells, with 3 components computed as follows. (In \b func, we refer to the
first component of a point using the variable "a", and to the second component, using
the variable "b").
- Component #0 = the second coordinate of the point; hence "IVec * b" in \b func.
- Component #1 = the first coordinate of the point; hence "JVec * a".
- Component #2 = distance between the point and SC origin (0.,0.); hence 
"KVec * sqrt( a*a + b*b )".

In addition we want to add 10.0 to each component computed as described above, hence
"10" in \b func.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingMesh_fillFromAnalytic_2
Now we ascertain that the result field is as we expect. We check the second tuple of
the \b field. We get barycenter of the cell #1 and checks that values of the second
tuple are computed as we want.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingMesh_fillFromAnalytic_3


\anchor cpp_mccmesh_getCoordsAt
<br><h2> Getting node coordinates </h2>

We create an 1D Cartesian mesh and retrieves node coordinates using
\ref ParaMEDMEM::MEDCouplingCMesh::getCoordsAt "getCoordsAt()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingCMesh_getCoordsAt_1



\anchor cpp_mcumesh_areCellsIncludedIn
<br><h2> Cells correspondence in two meshes </h2>

First, we create a 2D \b mesh1 with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_areCellsIncludedIn_1
Then we create a \b mesh2 which includes cells #4, #2 and #0 of \b mesh1. The two meshes
share the same node coordinates array.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_areCellsIncludedIn_2
Now we ascertain that
- \ref ParaMEDMEM::MEDCouplingUMesh::areCellsIncludedIn "areCellsIncludedIn()"
detects that all cells of \b mesh2 are present in \b mesh1,
-  the correspondence array \b corr2to1, which gives cell ids of \b mesh2 within
\b mesh1, is equal to the array \b cells2 which selected cells from \b mesh1 for creation
of \b mesh2.

\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_areCellsIncludedIn_3
Now we apply
\ref ParaMEDMEM::MEDCouplingUMesh::areCellsIncludedIn "areCellsIncludedIn()"
in a reverse direction and ascertain that it returns \c false. 
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_areCellsIncludedIn_4
The contents of the correspondence
array \b corr1to2 [2, 3, 1, 4, 0] means the following.
- The cell #0 of \b mesh1 is equal to the cell #2 (== \b corr1to2[ 0 ]) of \b mesh2.
- The cell #1 of \b mesh1 is missing from \b mesh2 (as \b corr1to2[ 1 ] >= \b mesh2->getNumberOfCells()).
- The cell #2 of \b mesh1 is equal to the cell #1 (== \b corr1to2[ 2 ]) of \b mesh2.
- The cell #3 of \b mesh1 is missing from \b mesh2 (as \b corr1to2[ 3 ] >= \b mesh2->getNumberOfCells()).
- The cell #4 of \b mesh1 is equal to the cell #0 (== \b corr1to2[ 4 ]) of \b mesh2.


\anchor cpp_mcumesh_checkDeepEquivalWith
<br><h2> Deep comparison of meshes </h2>

First, we create two 2D meshes with two triangles, so that 
- their nodes are almost same but permuted,
- the first triangle is based exactly on the same nodes (taking the permutation into account),
- an order of nodes in the second triangle is changed.

\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_checkDeepEquivalWith_1
Then we check that 
- \ref ParaMEDMEM::MEDCouplingUMesh::checkDeepEquivalWith "checkDeepEquivalWith()"
considers the meshes equal (i.e. it does not throw any exception) if it is called with a cell
comparison policy \b cellCompPol == 1
-  mapping from \b mesh1 to \b mesh2 for both nodes and cells is as expected.

\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_checkDeepEquivalWith_2
Next we ascertain that 
\ref ParaMEDMEM::MEDCouplingUMesh::checkDeepEquivalOnSameNodesWith "checkDeepEquivalOnSameNodesWith()"
consider \b mesh1 and \b mesh2 different as they do not share the same nodal connectivity
array. <br>
After that we make the meshes share the node coordinates array and insert new
triangles based on the same nodes but in different order. This is to ascertain that
\ref ParaMEDMEM::MEDCouplingUMesh::checkDeepEquivalOnSameNodesWith "checkDeepEquivalOnSameNodesWith()"
called with the weakest cell comparison policy considers the meshes equal.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_checkDeepEquivalWith_3



\anchor cpp_mcumesh_getPartBarycenterAndOwner
<br><h2> Getting barycenters of cells </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getPartMeasureField_1
Now we use
\ref ParaMEDMEM::MEDCouplingUMesh::getPartBarycenterAndOwner "getPartBarycenterAndOwner()" to get
barycenters of all but the first cell.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getPartMeasureField_3
The returned array contains 4 tuples per 2 components.


\anchor cpp_mcumesh_findAndCorrectBadOriented3DExtrudedCells
<br><h2> Fixing orientation of "extruded" volumes </h2>

First, we create a mesh with 2 incorrectly oriented "extruded" volumes.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_findAndCorrectBadOriented3DExtrudedCells_1
Now we check that
\ref ParaMEDMEM::MEDCouplingUMesh::findAndCorrectBadOriented3DExtrudedCells "findAndCorrectBadOriented3DExtrudedCells()"
finds and fixes the reversed cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_findAndCorrectBadOriented3DExtrudedCells_2


\anchor cpp_mcumesh_arePolyhedronsNotCorrectlyOriented
<br><h2> Fixing orientation of polyhedra </h2>

First, we create a mesh with 2 polyhedra, one of which is incorrectly oriented. We create
two "extruded" polyhedra and then convert them to correctly defined polyhedra.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_arePolyhedronsNotCorrectlyOriented_1
Now we check that
\ref ParaMEDMEM::MEDCouplingUMesh::arePolyhedronsNotCorrectlyOriented "arePolyhedronsNotCorrectlyOriented()"
finds one reversed cell. After that we fix it using
\ref ParaMEDMEM::MEDCouplingUMesh::orientCorrectlyPolyhedrons "orientCorrectlyPolyhedrons()" and
re-check the orientation of polyhedra.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_arePolyhedronsNotCorrectlyOriented_2


\anchor cpp_mcumesh_are2DCellsNotCorrectlyOriented
<br><h2> Fixing orientation of faces </h2>

First, we create a 2D mesh in 3D space with 3 QUAD4 and 2 TRI3 cells. Orientation of the cell #1 is
reversed comparing with others.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_are2DCellsNotCorrectlyOriented_1
Now we check that
\ref ParaMEDMEM::MEDCouplingUMesh::are2DCellsNotCorrectlyOriented "are2DCellsNotCorrectlyOriented()"
finds one reversed face. After that we fix the incorrectly oriented cell using
\ref ParaMEDMEM::MEDCouplingUMesh::orientCorrectly2DCells "orientCorrectly2DCells()" and
re-check the orientation of cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_are2DCellsNotCorrectlyOriented_2


\anchor cpp_mcumesh_getCellsContainingPoints
<br><h2> Finding cells containing a point (multi-point case) </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellsContainingPoints_1
Then we use 
\ref ParaMEDMEM::MEDCouplingUMesh::getCellsContainingPoints "getCellsContainingPoints()" to
get cells in contact with tree points. Two of them are in contact with some cells and one is not.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellsContainingPoints_2
The contents of the result arrays \b cells ([4, 0, 1]) and \b cellsIndex ([0, 0, 1, 3])
mean the following.
- Point #0 is in contact with none (== \b cellsIndx[1] - \b cellsIndx[0]) cell.
- Point #1 is in contact with 1 (== \b cellsIndx[2] - \b cellsIndx[1]) cell whose id is #4
  (== \b cells[ \b cellsIndx[ 1 ]]).
- Point #2 is in contact with 2 (== \b cellsIndx[3] - \b cellsIndx[2]) cells whose ids are #0 
  (== \b cells[ \b cellsIndx[ 2 ]]) and #1 (== \b cells[ \b cellsIndx[ 2 ] + 1 ]).


\anchor cpp_mcumesh_getCellsContainingPoint
<br><h2> Finding cells containing a point </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellsContainingPoint_1
Then we use 
\ref ParaMEDMEM::MEDCouplingUMesh::getCellsContainingPoint "getCellsContainingPoint()" to
get cells in contact with a small ball (point with precision) located near the node #4 and
shifted from this node by its radius \b eps.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellsContainingPoint_2
Since the node #4 is shared by all cells, size of the vector \b cellIds must be equal to
the number of cells in \b mesh.

\anchor cpp_mcumesh_buildPartOrthogonalField
<br><h2> Getting normals of cells </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells. Orientation of the cell #1 is
reversed.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildPartOrthogonalField_1
Now we use
\ref ParaMEDMEM::MEDCouplingUMesh::buildPartOrthogonalField "buildPartOrthogonalField()" to get
normal vectors to the cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildPartOrthogonalField_2



\anchor cpp_mcumesh_getPartMeasureField
<br><h2> Getting volumes of cells </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells. Orientation of the cell #1 is
reversed.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getPartMeasureField_1
Now we use
\ref ParaMEDMEM::MEDCouplingUMesh::getPartMeasureField "getPartMeasureField()" to get
volumes of all but the first cell. If we call
\ref ParaMEDMEM::MEDCouplingUMesh::getPartMeasureField "getPartMeasureField()" with \b
isAbs == \c true, the area of the cell #1 is returned positive, else, negative that
reflects its inverse orientation.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getPartMeasureField_2



\anchor cpp_mcumesh_getCellsInBoundingBox
<br><h2> Getting cells using the bounding box </h2>

First, we create a 2D mesh with 1 TRI3 cell. Bounding box of this cell is [0.,0., 1.,1].
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellsInBoundingBox_1
Now we check how 
\ref ParaMEDMEM::MEDCouplingUMesh::getCellsInBoundingBox "getCellsInBoundingBox()"
searches for cells using the bounding box. We use a bounding box touching the bounding box
of the sole cell at one point (1.,1.).
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellsInBoundingBox_2
If \ref ParaMEDMEM::MEDCouplingUMesh::getCellsInBoundingBox "getCellsInBoundingBox()" is
called with parameter \b eps == 0.0, the cell is not found because the two bounding boxes
(one of the cell and the one passed as parameter) do not overlap. <br>
If \ref ParaMEDMEM::MEDCouplingUMesh::getCellsInBoundingBox "getCellsInBoundingBox()" is
called with parameter \b eps == 0.1, the cell is found because \b eps is used to increase
the bounding box of the cell and thus the two bounding boxes intersect each other. <br>

\anchor cpp_mcumesh_renumberNodesInConn
<br><h2> Renumbering nodes in the connectivity array </h2>

First, we create a 2D mesh with 1 QUAD4 cell and with undefined coordinates of nodes.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_renumberNodesInConn_1
Now we use
\ref ParaMEDMEM::MEDCouplingUMesh::renumberNodesInConn "renumberNodesInConn()"
to get the following nodal connectivity of a sole cell: 0,1,2,3.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_renumberNodesInConn_2
\b old2newIds array defines how node ids are changed:
- new id of node #0 is -1,
- new id of node #1 is 3,
- new id of node #2 is 4,
- new id of node #3 is 1,
- new id of node #4 is 0.

\anchor cpp_mcumesh_renumberNodes
<br><h2> Renumbering nodes </h2>

First, we create a 2D mesh with 4 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_renumberNodes_1
Next, we use 
\ref ParaMEDMEM::MEDCouplingUMesh::renumberNodes "renumberNodes()"
to permute nodes so that
- old node #0 becomes #2,
- old node #1 remains #1,
- old node #2 becomes #0,
- old node #3 is removed.

Number of nodes becomes 3.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_renumberNodes_2

Next we compare behavior of 
\ref ParaMEDMEM::MEDCouplingUMesh::renumberNodes "renumberNodes()" and that of
\ref ParaMEDMEM::MEDCouplingUMesh::renumberNodes2 "renumberNodes2()" which, in contrast to
\ref ParaMEDMEM::MEDCouplingUMesh::renumberNodes "renumberNodes()",
moves merged nodes to their barycenter.<br> 
We set #2 as new id of old node #3 and expect that 
\ref ParaMEDMEM::MEDCouplingUMesh::renumberNodes2 "renumberNodes2()" moves old nodes #0
and #3 to their barycenter (-0.3,0.0) which becomes position of node #2.<br>
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_renumberNodes_3


\anchor cpp_mcumesh_findBoundaryNodes
<br><h2> Getting boundary nodes </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_findBoundaryNodes_1
Now we use 
\ref ParaMEDMEM::MEDCouplingUMesh::findBoundaryNodes "findBoundaryNodes()" to get ids
of boundary nodes.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_findBoundaryNodes_2
\ref ParaMEDMEM::MEDCouplingUMesh::findBoundaryNodes "findBoundaryNodes()" returns all
node ids except the node #4 which is in the middle of \b mesh.


\anchor cpp_mcumesh_buildBoundaryMesh
<br><h2> Getting a bounding mesh </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildBoundaryMesh_1
Now we use 
\ref ParaMEDMEM::MEDCouplingUMesh::buildBoundaryMesh "buildBoundaryMesh()" to get a mesh
of lower dimension bounding \b mesh.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildBoundaryMesh_2
Depending on the value of a parameter,
\ref ParaMEDMEM::MEDCouplingUMesh::buildBoundaryMesh "buildBoundaryMesh()"
creates the mesh sharing the node coordinates array with \b mesh or not.


\anchor cpp_mcumesh_buildFacePartOfMySelfNode
<br><h2> Retrieving a lower dimension mesh based on given nodes </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildFacePartOfMySelfNode_1
In the following code we retrieve nodes of the cell #0 an then we call
\ref ParaMEDMEM::MEDCouplingUMesh::buildFacePartOfMySelfNode "buildFacePartOfMySelfNode()" 
twice with these nodes and with varying last parameter \b allNodes as input.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildFacePartOfMySelfNode_2
<br>If the last parameter is \c true 
\ref ParaMEDMEM::MEDCouplingUMesh::buildFacePartOfMySelfNode "buildFacePartOfMySelfNode()" looks
for segements whose all nodes are given to it, hence it finds segments bounding the cell #0 only.
<br>If the last parameter is \c false
\ref ParaMEDMEM::MEDCouplingUMesh::buildFacePartOfMySelfNode "buildFacePartOfMySelfNode()" looks
for any segment whose nodes are given to it, hence it adds more segments to \b mesh2.


\anchor cpp_mcumesh_buildPartOfMySelfNode
<br><h2> Copying cells selected by nodes </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildPartOfMySelfNode_1
In the following code we retrieve nodes of the cell #0 an then we call
\ref ParaMEDMEM::MEDCouplingUMesh::buildPartOfMySelfNode "buildPartOfMySelfNode()" 
twice with these nodes and with varying last parameter \b allNodes as input.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildPartOfMySelfNode_2
<br>If the last parameter is \c true 
\ref ParaMEDMEM::MEDCouplingUMesh::buildPartOfMySelfNode "buildPartOfMySelfNode()" looks
for cells whose all nodes are given to it, hence it finds the cell #0 only.
<br>If the last parameter is \c false
\ref ParaMEDMEM::MEDCouplingUMesh::buildPartOfMySelfNode "buildPartOfMySelfNode()" looks
for any cell whose nodes are given to it, hence it finds all cells of \b mesh because all
cells share the node #4.


\anchor cpp_mcumesh_getCellIdsLyingOnNodes
<br><h2> Getting cells by nodes </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellIdsLyingOnNodes_1
In the following code we retrieve nodes of the cell #0 an then we call
\ref ParaMEDMEM::MEDCouplingUMesh::getCellIdsLyingOnNodes "getCellIdsLyingOnNodes()" 
twice with these nodes and with varying last parameter \b allNodes as input.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellIdsLyingOnNodes_2
<br>If the last parameter is \c true 
\ref ParaMEDMEM::MEDCouplingUMesh::getCellIdsLyingOnNodes "getCellIdsLyingOnNodes()" looks
for cells whose all nodes are given to it, hence it finds the cell #0 only.
<br>If the last parameter is \c false
\ref ParaMEDMEM::MEDCouplingUMesh::getCellIdsLyingOnNodes "getCellIdsLyingOnNodes()" looks
for any cell whose nodes are given to it, hence it finds all cells of \b mesh because all
cells share the node #4.



\anchor cpp_mcumesh_getCellIdsFullyIncludedInNodeIds
<br><h2> Getting cells by nodes </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellIdsFullyIncludedInNodeIds_1
In the following code we retrieve nodes of two cells an then we use 
\ref ParaMEDMEM::MEDCouplingUMesh::getCellIdsFullyIncludedInNodeIds
"getCellIdsFullyIncludedInNodeIds()" to find these cells by their nodes.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getCellIdsFullyIncludedInNodeIds_2


\anchor cpp_mcumesh_buildPartOfMySelf
<br><h2> Getting a part of mesh </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildPartOfMySelf_1
Now we use 
\ref ParaMEDMEM::MEDCouplingUMesh::buildPartOfMySelf "buildPartOfMySelf()" to get a mesh
containing only two cells of \b mesh. 
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildPartOfMySelf_2


\anchor cpp_mcumesh_mergeNodes
<br><h2> Merging equal nodes </h2>

First, we create a 2D mesh with 1 QUAD4 and 2 TRI3 cells. The cells are based on 6 nodes
of which 2 nodes fully coincide (#3 and #4) and 3 nodes are equal with precision 0.003.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_mergeNodes_1
Now we merge node duplicates using
\ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "mergeNodes()" and check values it returns.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_mergeNodes_2
Contents of \b arr shows ids of old nodes after the merging. The nodes considered equal
one to the other have the same id in \b arr.

Next we compare behavior of 
\ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "mergeNodes()" and that of
\ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes2 "mergeNodes2()" which, in contrast to
\ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "mergeNodes()",
moves merged nodes to their barycenter.<br> We expect that 
\ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes2 "mergeNodes2()" moves old nodes #0, #2 
and #5 to their barycenter equal to position of node #2.<br>
First we check that 
\ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "mergeNodes()" does not move nodes
coincident with the node #2 to the position of node #2, and then we check that 
\ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "mergeNodes2()" does move.
(We check only the second (Y) component of node coordinates since the first component of
these nodes is exactly same.)
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_mergeNodes_3



\anchor cpp_mcumesh_zipConnectivityTraducer
<br><h2> Removing cell duplicates </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells, so that
- the cell #2 has the same nodal connectivity as the cell #1 does,
- the cell #3 has the same nodal connectivity as the cell #0 does,
- the cell #4 is based on the same nodes as the cell #0 but nodes order is different.

\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_zipConnectivityTraducer_1
Now we use 
\ref ParaMEDMEM::MEDCouplingUMesh::zipConnectivityTraducer "zipConnectivityTraducer()" 
to remove duplicate cells. Then we check that two cells, having exactly same nodal
connectivity with other cells, have been removed.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_zipConnectivityTraducer_2
Contents of \b arr shows ids of cells after duplicates removal. If a value (cell id)
equals to its index in \b arr, this means that the cell is not a duplicate of any cell
with lower id. Else, the value gives a cell id to which this cell is equal. <br>
Thus, the cells #0 and #1 have no preceding equal cell since \b arr[i] == i.<br>
The cell #2 equals to the cell #1 (== \b arr[2] ).<br>
The cell #3 equals to the cell #0 (== \b arr[3] ).<br>
The cell #4 has no equal cell. This is because the cell comparison technique specified
when we called 
\ref ParaMEDMEM::MEDCouplingUMesh::zipConnectivityTraducer "zipConnectivityTraducer()" 
was 0 ("exact"), if we had used the technique 2 ("nodal"), \b arr[4] would be 0.



\anchor cpp_mcumesh_zipCoordsTraducer
<br><h2> Removing unused nodes </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_zipCoordsTraducer_1
Now we create \b mesh2 including all nodes but only two cells of \b mesh, and we use \ref
ParaMEDMEM::MEDCouplingUMesh::zipCoordsTraducer "zipCoordsTraducer()" to remove unused
nodes from \b mesh2. 
\ref ParaMEDMEM::MEDCouplingUMesh::zipCoordsTraducer "zipCoordsTraducer()" returns an array
with -1 for unused nodes and new ids for used ones.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_zipCoordsTraducer_2



\anchor cpp_mcumesh_getNodeIdsInUse
<br><h2> Retrieving unused nodes </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getNodeIdsInUse_1
Now we create \b mesh2 including all nodes but only two cells of \b mesh, and we use \ref
ParaMEDMEM::MEDCouplingUMesh::getNodeIdsInUse "getNodeIdsInUse()" to get nodes of \b mesh2
used in its two cells. 
\ref ParaMEDMEM::MEDCouplingUMesh::getNodeIdsInUse "getNodeIdsInUse()" returns an array
with -1 for unused nodes and new ids for used ones.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getNodeIdsInUse_2
Now we use \b newNbOfNodes returned by 
\ref ParaMEDMEM::MEDCouplingUMesh::getNodeIdsInUse "getNodeIdsInUse()" to convert \b arr
to "New to Old" mode.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getNodeIdsInUse_3


\anchor cpp_mcumesh_convertToPolyTypes
<br><h2> Conversion of cells to "poly" types </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_convertToPolyTypes_1
Now we convert cells #1 and #3 to type POLYGON and check the result
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_convertToPolyTypes_2


\anchor cpp_mcumesh_buildDescendingConnectivity2
<br><h2> Retrieving the descending connectivity with orientation </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildDescendingConnectivity2_1
Now we get and check the descending connectivity.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildDescendingConnectivity2_2
Here we get connectivity of the cell #2 (#3 in FORTRAN mode) of \b mesh2 to see how
mutual orientation of cells in \b mesh and \b mesh2 is defined.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildDescendingConnectivity2_3
The contents of the result arrays \b desc and \b descIndx mean the following.
- The cell #0 of \b mesh (QUAD4) is bound by 4 (== \b descIndx[1] - \b descIndx[0])
  segments (SEG2) of \b mesh2 whose ids in FORTRAN mode are
  - #1 (== \b desc[ \b descIndx[ 0 ]]),
  - #2 (== \b desc[ \b descIndx[ 0 ] + 1 ]), 
  - #3 (== \b desc[ \b descIndx[ 0 ] + 2 ]) and 
  - #4 (== \b desc[ \b descIndx[ 0 ] + 3 ]).
  <br>Ids are positive since order of nodes in the corresponding cells of \b mesh and \b mesh2
  are same. For example nodes of SEG2 #3 are [4,1] and nodes of QUAD4 #0 are [0,3,\b 4,\b 1].
- The cell #1 of \b mesh (TRI3) is bound by 3 (== \b descIndx[2] - \b descIndx[1]) segements of
  \b mesh2 whose ids in FORTRAN mode are: 
  - #-3 (== \b desc[ \b descIndx[ 1 ]]),
  - #5 (== \b desc[ \b descIndx[ 1 ] + 1 ]) and 
  - #6 (== \b desc[ \b descIndx[ 1 ] + 2 ]).
  <br>The id -3 means that order of nodes in SEG2 #3 ([4,1]) is different from the order of
  these nodes in TRI3 #1: [\b 1,\b 4,2].
- etc.

The contents of the result arrays \b revDesc and \b revDescIndx mean the following.
- The cell #0 of \b mesh2 (SEG2) bounds 1 (== \b revDescIndx[1] - \b revDescIndx[0]) cell of \b
  mesh whose id is:
  - # 0 (== \b revDesc[ \b revDescIndx[ 0 ]]).
- The cell #1 of \b mesh2 bounds 2 (== \b revDescIndx[2] - \b revDescIndx[1]) cells of \b
  mesh whose ids are:
  - # 0 (== \b revDesc[ \b revDescIndx[ 1 ]]) and
  - # 1 (== \b revDesc[ \b revDescIndx[ 1 ] + 1 ]).
- etc.



\anchor cpp_mcumesh_buildDescendingConnectivity
<br><h2> Retrieving the descending connectivity </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildDescendingConnectivity_1
Now we get and check the descending connectivity.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildDescendingConnectivity_2
The contents of the result arrays \b desc and \b descIndx mean the following.
- The cell #0 of \b mesh (QUAD4) is bound by 4 (== \b descIndx[1] - \b descIndx[0])
  segments (SEG2) of \b mesh2 whose ids are 
  - #0 (== \b desc[ \b descIndx[ 0 ]]), 
  - #1 (== \b desc[ \b descIndx[ 0 ] + 1 ]), 
  - #2 (== \b desc[ \b descIndx[ 0 ] + 2 ]) and 
  - #3 (== \b desc[ \b descIndx[ 0 ] + 3 ]).
- The cell #1 of \b mesh (TRI3) is bound by 3 (== \b descIndx[2] - \b descIndx[1]) segements of
  \b mesh2 whose ids are: 
  - #2 (== \b desc[ \b descIndx[ 1 ]]), 
  - #4 (== \b desc[ \b descIndx[ 1 ] + 1 ]) and 
  - #5 (== \b desc[ \b descIndx[ 1 ] + 2 ]).
- etc.

The contents of the result arrays \b revDesc and \b revDescIndx mean the following.
- The cell #0 of \b mesh2 (SEG2) bounds 1 (== \b revDescIndx[1] - \b revDescIndx[0]) cell of \b
  mesh whose id is:
  - # 0 (== \b revDesc[ \b revDescIndx[ 0 ]]).
- The cell #1 of \b mesh2 bounds 2 (== \b revDescIndx[2] - \b revDescIndx[1]) cells of \b
  mesh whose ids are:
  - # 0 (== \b revDesc[ \b revDescIndx[ 1 ]]) and
  - # 1 (== \b revDesc[ \b revDescIndx[ 1 ] + 1 ]).
- etc.


\anchor cpp_mcumesh_getReverseNodalConnectivity
<br><h2> Getting the reverse nodal connectivity </h2>

First, we create a 2D mesh with 3 QUAD4 and 2 TRI3 cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getReverseNodalConnectivity_1
Now we get and check its reverse nodal connectivity.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_getReverseNodalConnectivity_2
The contents of the result arrays mean the following.
- Node #0 is shared by 1 (== \b revNodalIndx[1] - \b revNodalIndx[0]) cell whose id is #0 
  (== \b revNodal[ \b revNodalIndx[ 0 ]]).
- Node #1 is shared by 2 (== \b revNodalIndx[2] - \b revNodalIndx[1]) cells whose ids are #0 
  (== \b revNodal[ \b revNodalIndx[ 1 ]]) and #1 (== \b revNodal[ \b revNodalIndx[ 1 ] + 1 ]).
- etc.

\anchor cpp_mcpointset_scale
<br><h2> Scaling the mesh </h2>

First, we create a 2D mesh with 4 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_scale_1
Then we scale it by a factor of 2 with a center (0.,0.).
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_scale_2
Finally we check that all node coordinates have changed by more than 0.9.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_scale_3




\anchor cpp_mcpointset_translate
<br><h2> Translating the mesh </h2>

First, we create a 2D mesh with 4 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_translate_1
Then we translate it by a vector (1.,1.).
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_translate_2
Finally we check that all node coordinates have changed by more than 0.9.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_translate_3



\anchor cpp_mcpointset_rotate
<br><h2> Rotating the mesh </h2>

First, we create a 2D mesh with 4 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_rotate_1
Then we rotate it around a point (0.,0.) by 90 degrees clockwise.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_rotate_2
Next, we make a 3D mesh from the 2D one and rotate it around the Z axis by 90 degrees
counter-clockwise. 
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_rotate_3
Finally we transform the mesh back to 2D space and check that all nodes get back to the
initial location.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_rotate_4

\anchor cpp_mcpointset_getBoundingBox
<br><h2> Getting a minimum box bounding nodes </h2>

First, we create a 3D mesh with 2 nodes, so that the first one has minimal coordinates and
the second one has maximal coordinates.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getBoundingBox_1
Now we get a bounding box enclosing these nodes. This bounding box should contain
coordinates of our two nodes (but in "no interlace" mode), as the nodes coincide with
points returned by the bounding box.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getBoundingBox_2


\anchor cpp_mcpointset_getnodeidsnearpoint
<br><h2> Getting nodes close to a point </h2>

The following code creates a 2D \ref ParaMEDMEM::MEDCouplingUMesh
"MEDCouplingUMesh" with 5 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getNodeIdsNearPoint_1
Now we define an array of coordinates of a point close to nodes #0, #2 and #4.

Thus we expect that 
\ref ParaMEDMEM::MEDCouplingPointSet::getNodeIdsNearPoint "getNodeIdsNearPoint()" that
we are going to use,
if called with \b eps = 0.003, would return ids of nodes #0, #2 and #4.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getNodeIdsNearPoint_2


\anchor cpp_mcpointset_getnodeidsnearpoints
<br><h2> Getting nodes close to some points </h2>

The following code creates a 2D \ref ParaMEDMEM::MEDCouplingUMesh
"MEDCouplingUMesh" with 7 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getNodeIdsNearPoints_1
Now we define an array of coordinates of 3 points near which we want to find nodes of the mesh.
- Point #0 is at distance 0.001 from the node #1.
- Point #1 is rather far from all nodes.
- Point #2 is close to nodes #3, #4 and #5.

Thus we expect that 
\ref ParaMEDMEM::MEDCouplingPointSet::getNodeIdsNearPoints "getNodeIdsNearPoints()" that
we are going to use,
if called with \b eps = 0.003, would return ids of close nodes #1, #3, #4 and #5.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getNodeIdsNearPoints_2
\b idsIndex returns [0, 1, 1, 4] which means that:
- Point #0 is close to 1 (== \b idsIndex[1] - \b idsIndex[0]) node whose id is 
\b ids[ \b idsIndex[ 0 ]].
- Point #1 is close to 0 (== \b idsIndex[2] - \b idsIndex[1]) nodes.
- Point #2 is close to 3 (== \b idsIndex[3] - \b idsIndex[2]) nodes whose ids are
\b ids[ \b idsIndex[ 2 ]], \b ids[ \b idsIndex[ 2 ] + 1 ] and \b ids[ \b idsIndex[ 2 ] + 2 ].


\anchor cpp_mcpointset_findcommonnodes
<br><h2> Finding coincident nodes </h2>

First, we create a mesh with 6 nodes, of which two nodes (#3 and #4) are fully coincident
and 3 nodes (#0, #2 and #5) have distance less than 0.004 between them.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_findCommonNodes_1
Then, we use \ref ParaMEDMEM::MEDCouplingPointSet::findCommonNodes() "findCommonNodes()" to find
coincident nodes, and check that (1) calling 
\ref ParaMEDMEM::MEDCouplingPointSet::findCommonNodes() "findCommonNodes()" with \b prec
== 1e-13 finds the two fully coincident nodes only and (2)
\ref ParaMEDMEM::MEDCouplingPointSet::findCommonNodes() "findCommonNodes"(0.004) finds 5
equal nodes.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_findCommonNodes_2

\anchor cpp_mcpointset_getcoordinatesofnode
<br><h2> Getting coordinates of a node </h2>

The following code creates a 2D \ref ParaMEDMEM::MEDCouplingUMesh
"MEDCouplingUMesh" with 3 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getCoordinatesOfNode_1
Here we get coordinates of the second node and check its two coordinates.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getCoordinatesOfNode_2

\anchor cpp_mcdataarrayint_getTuple
<br><h2> Getting a tuple of DataArrayInt </h2>

In this simple example we create an array of integers arranged into 3
tuples per 2 components, and finally print the second tuple.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_getTuple_1
The output is
<pre> [9, 10] </pre>
Note that we can traverse all tuples in the array by simply iterating
over it as the code below does.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_getTuple_2
Its output follows.
<pre>
(7, 8)
(9, 10)
(11, 12)
</pre>

\anchor cpp_mcdataarrayint_buildpermutationarr
<br><h2> Building a permutation array </h2>

Here we create two arrays containing same values but in different order and then we use
\ref ParaMEDMEM::DataArrayInt::buildPermutationArr "DataArrayInt::buildPermutationArr()" to get
an array showing in what places the values of \b b array are located in \b a array.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayInt_buildPermutationArr_1
The result array \b c contains [1,0,4,2,3].

<br><h2> Inverting renumbering maps </h2>
\anchor cpp_mcdataarrayint_invertarrayo2n2n2o
<h3> invertArrayO2N2N2O() </h3>

In this example we create a DataArrayInt containing a renumbering map in 
"Old to New" mode, convert it into the renumbering map in "New to Old" mode and check the
result.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayInt_invertArrayO2N2N2O_1

\anchor cpp_mcdataarrayint_invertarrayn2o2o2n
<br><h3> invertArrayN2O2O2N() </h3>

In this example we create a DataArrayInt containing a renumbering map in 
"New to Old" mode, convert it into the renumbering map in "Old to New" mode and check the
result.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayInt_invertArrayN2O2O2N_1



\anchor cpp_mcdataarraydouble_getidsinrange
<br><h2> Finding values in range in  DataArrayDouble</h2>

In this example we create an array \b da containing same values as ones returned by
\c range( \c 10 ). Then we get an array of indices of values of \b da being in
range [ 2.5, 6 ].
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayDouble_getIdsInRange_1
As result contents of the array \b da2 are as follows.
<pre>
    Tuple #0 : 3
    Tuple #1 : 4
    Tuple #2 : 5
    Tuple #3 : 6
</pre>


\anchor cpp_mcdataarraydouble_setselectedcomponents
<br><h2> Set part of values of DataArrayDouble </h2>
<h3> setSelectedComponents() </h3>
First, we create a 'source' array.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setSelectedComponents1
Now we create a larger zero array and assign the array \b da into it.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setSelectedComponents2
As result contents of the array \b dv are as follows.
<pre>
Info of components : "a2"   "a1"   "v3"   "v4"   
    Tuple #0 : 2 1 0 0 
    Tuple #1 : 4 3 0 0 
    Tuple #2 : 6 5 0 0 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way (except that component info
is not copied):
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setSelectedComponents3

\anchor cpp_mcdataarraydouble_setpartofvalues1
<br><h3> setPartOfValues1() </h3>
We create two arrays: 
- a "large" (4x4) zero array \b da to assign to and
- a smaller (2x2) array \b dv filled with values [7.,8.,9.,10].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_1
Now we copy \b dv to the middle of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_2
As result contents of the array \b da are as follows.
<pre>
    Info of components :"v1"   "v2"   "v3"   "v4"
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 8 0 
    Tuple #2 : 0 9 10 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and copy \b dv into a component of \b da.

Note that the last parameter \b strictCompoCompare should be \c False
in this case, else \ref ParaMEDMEM::DataArrayDouble::setPartOfValues1() 
throws an exception because \b da has 2 components but only one target
component is specified.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 8 0 0 
    Tuple #2 : 0 9 0 0 
    Tuple #3 : 0 10 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 8 9 10 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_5
<pre>
    Tuple #0 : 0 7 0 8 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 9 0 10 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way:
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_6



\anchor cpp_mcdataarraydouble_setpartofvaluessimple1
<br><h3> setPartOfValuesSimple1() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_1
Now we assign \b dv to the middle of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way:
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_6


\anchor cpp_mcdataarraydouble_setpartofvaluessimple2
<br><h3> setPartOfValuesSimple2() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_1
Now we assign \b dv to the middle of \b da.
We explicitly specify tuples and component to assign to by a list [1,2].
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
\note \ref ParaMEDMEM::DataArrayDouble::setPartOfValuesSimple2() can't
be explicitly called in Python.


\anchor cpp_mcdataarraydouble_setpartofvaluessimple3
<br><h3> setPartOfValuesSimple3() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_1
Now we assign \b dv to the middle of \b da.
We explicitly specify tuples to assign to by a list [1,2]. And we specify
components to assign to using slicing: 1:3.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
\note \ref ParaMEDMEM::DataArrayDouble::setPartOfValuesSimple3() can't
be explicitly called in Python.


\anchor cpp_mcdataarraydouble_setpartofvalues2
<br><h3> setPartOfValues2() </h3>
We create two arrays: 
- a "large" (4x7) zero array \b da to assign to,
- a smaller (3x2) array \b dv filled with values [7.,8.,9.,10.,11.,12.].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues2_1
Now we assign the two components of \b dv to the components of \b da
with indices [1,3], and the 3 tuples of \b dv to the 3 tuples of \b da with
  indices [0,1,2]. This is the first mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues2_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0  7  0  8  0  0  0  
    Tuple #1 : 0  9  0 10  0  0  0 
    Tuple #2 : 0 11  0 12  0  0  0 
    Tuple #3 : 0  0  0  0  0  0  0
</pre>
Every value of \b dv has been assigned to its own location within \b da.

Now we re-fill \b da with zeros and rearrange \b dv to have 6 components.
And we assign \b dv to the tuples of \b da with indices [0,2,3] .
This is the second mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues2_3
The contents of \b dv have been assigned to each of specified tuples of \b da.
Every value of \b dv is repeated in the 3 specified tuples within \b da.
<pre>
    Tuple #0 : 7  0  8  9 10 11 12
    Tuple #1 : 0  0  0  0  0  0  0   
    Tuple #2 : 7  0  8  9 10 11 12
    Tuple #3 : 7  0  8  9 10 11 12
</pre>
\note \ref ParaMEDMEM::DataArrayDouble::setPartOfValues2() can't
be explicitly called in Python.


\anchor cpp_mcdataarraydouble_setpartofvalues3
<br><h3> setPartOfValues3() </h3>
We create two arrays: 
- a "large" (4x7) zero array \b da to assign to,
- a smaller (3x2) array \b dv filled with values [7.,8.,9.,10.,11.,12.].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues3_1
Now we assign the two components of \b dv to the components of \b da
with indices [1,3], and the 3 tuples of \b dv to the 3 tuples of \b da with
indices [0,1,2] which are specified using slicing: "0:3". 
This is the first mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues3_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0  7  0  8  0  0  0  
    Tuple #1 : 0  9  0 10  0  0  0 
    Tuple #2 : 0 11  0 12  0  0  0 
    Tuple #3 : 0  0  0  0  0  0  0
</pre>
Every value of \b dv has been assigned to its own location within \b da.

Now we re-fill \b da with zeros and rearrange \b dv to have 6 components.
And we assign \b dv to the tuples of \b da with indices [0,2] using \a
slice notation "0:4:2". This is the second mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues3_3
The contents of \b dv have been assigned to each of specified tuples of \b da.
Every value of \b dv is repeated in the 3 specified tuples within \b da.
<pre>
    Tuple #0 : 7  0  8  9 10 11 12
    Tuple #1 : 0  0  0  0  0  0  0   
    Tuple #2 : 7  0  8  9 10 11 12
    Tuple #3 : 0  0  0  0  0  0  0   
</pre>
\note \ref ParaMEDMEM::DataArrayDouble::setPartOfValues3() can't
be explicitly called in Python.


\anchor cpp_mcdataarrayint_setselectedcomponents
<br><h2> Set part of values of DataArrayInt </h2>
<h3> setSelectedComponents() </h3>
First, we create a 'source' array.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setSelectedComponents1
Now we create a larger zero array and assign the array \b da to it.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setSelectedComponents2
As result contents of the array \b dv are as follows.
<pre>
Info of components : "a2"   "a1"   "v3"   "v4"   
    Tuple #0 : 2 1 0 0 
    Tuple #1 : 4 3 0 0 
    Tuple #2 : 6 5 0 0 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way (except that component info
is not copied):
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setSelectedComponents3

\anchor cpp_mcdataarrayint_setpartofvalues1
<br><h3> setPartOfValues1() </h3>
We create two arrays: 
- a "large" (4x4) zero array \b da to assign to and
- a smaller (2x2) array \b dv filled with values [7,8,9,10].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_1
Now we copy \b dv to the middle of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_2
As result contents of the array \b da are as follows.
<pre>
    Info of components :"v1"   "v2"   "v3"   "v4"
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 8 0 
    Tuple #2 : 0 9 10 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and copy \b dv into a component of \b da.

Note that the last parameter \b strictCompoCompare should be \c False
in this case, else \ref ParaMEDMEM::DataArrayInt::setPartOfValues1() 
throws an exception because \b da has 2 components but only one target
component is specified.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 8 0 0 
    Tuple #2 : 0 9 0 0 
    Tuple #3 : 0 10 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 8 9 10 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_5
<pre>
    Tuple #0 : 0 7 0 8 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 9 0 10 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way:
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_6



\anchor cpp_mcdataarrayint_setpartofvaluessimple1
<br><h3> setPartOfValuesSimple1() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_1
Now we assign \b dv to the middle of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way:
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_6


\anchor cpp_mcdataarrayint_setpartofvaluessimple2
<br><h3> setPartOfValuesSimple2() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_1
Now we assign \b dv to the middle of \b da.
We explicitly specify tuples and component to assign to by a list [1,2].
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
\note \ref ParaMEDMEM::DataArrayInt::setPartOfValuesSimple2() can't
be explicitly called in Python.


\anchor cpp_mcdataarrayint_setpartofvaluessimple3
<br><h3> setPartOfValuesSimple3() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_1
Now we assign \b dv to the middle of \b da.
We explicitly specify tuples to assign to by a list [1,2]. And we specify
components to assign to using slicing: 1:3.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
\note \ref ParaMEDMEM::DataArrayInt::setPartOfValuesSimple3() can't
be explicitly called in Python.


\anchor cpp_mcdataarrayint_setpartofvalues2
<br><h3> setPartOfValues2() </h3>
We create two arrays: 
- a "large" (4x7) zero array \b da to assign to,
- a smaller (3x2) array \b dv filled with values [7,8,9,10,11,12].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues2_1
Now we assign the two components of \b dv to the components of \b da
with indices [1,3], and the 3 tuples of \b dv to the 3 tuples of \b da with
  indices [0,1,2]. This is the first mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues2_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0  7  0  8  0  0  0  
    Tuple #1 : 0  9  0 10  0  0  0 
    Tuple #2 : 0 11  0 12  0  0  0 
    Tuple #3 : 0  0  0  0  0  0  0
</pre>
Every value of \b dv has been assigned to its own location within \b da.

Now we re-fill \b da with zeros and rearrange \b dv to have 6 components.
And we assign \b dv to the tuples of \b da with indices [0,2,3] .
This is the second mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues2_3
The contents of \b dv have been assigned to each of specified tuples of \b da.
Every value of \b dv is repeated in the 3 specified tuples within \b da.
<pre>
    Tuple #0 : 7  0  8  9 10 11 12
    Tuple #1 : 0  0  0  0  0  0  0   
    Tuple #2 : 7  0  8  9 10 11 12
    Tuple #3 : 7  0  8  9 10 11 12
</pre>
\note \ref ParaMEDMEM::DataArrayInt::setPartOfValues2() can't
be explicitly called in Python.


\anchor cpp_mcdataarrayint_setpartofvalues3
<br><h3> setPartOfValues3() </h3>
We create two arrays: 
- a "large" (4x7) zero array \b da to assign to,
- a smaller (3x2) array \b dv filled with values [7,8,9,10,11,12].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues3_1
Now we assign the two components of \b dv to the components of \b da
with indices [1,3], and the 3 tuples of \b dv to the 3 tuples of \b da with
indices [0,1,2] which are specified using slicing: "0:3". 
This is the first mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues3_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0  7  0  8  0  0  0  
    Tuple #1 : 0  9  0 10  0  0  0 
    Tuple #2 : 0 11  0 12  0  0  0 
    Tuple #3 : 0  0  0  0  0  0  0
</pre>
Every value of \b dv has been assigned to its own location within \b da.

Now we re-fill \b da with zeros and rearrange \b dv to have 6 components.
And we assign \b dv to the tuples of \b da with indices [0,2] using \a
slice notation "0:4:2". This is the second mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues3_3
The contents of \b dv have been assigned to each of specified tuples of \b da.
Every value of \b dv is repeated in the 3 specified tuples within \b da.
<pre>
    Tuple #0 : 7  0  8  9 10 11 12
    Tuple #1 : 0  0  0  0  0  0  0   
    Tuple #2 : 7  0  8  9 10 11 12
    Tuple #3 : 0  0  0  0  0  0  0   
</pre>
\note \ref ParaMEDMEM::DataArrayInt::setPartOfValues3() can't
be explicitly called in Python.


\anchor cpp_mcdataarraydouble_getdifferentvalues
<br><h2> Excluding coincident tuples from DataArrayDouble</h2>

The code below creates an array of real values and than an array of
  unique values, not closer one to another than 0.2, is retrieved from it.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_getDifferentValues1


\anchor cpp_mcdataarraydouble_findcommontuples
<br><h2> Finding coincident tuples in DataArrayDouble</h2>

Let's create an array of 6 tuples and 2 components that can be
  considered as coordinates of 6 points in 2D space.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayDouble_findCommonTuples1
Now we find points that are not far each from other than 1e-1.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayDouble_findCommonTuples2
As we can realize from the above code, a hardcoded array \b expected3 is equal
  to the raw data of a DataArrayInt \b c and a hardcoded array \b expected4 is equal
  to the raw data of the DataArrayInt \b cI.

The array \b c contains indices of 5 coincident points. The array \b
  cI shows us boundaries of (cI->getNumberOfTuples()-1) = 2 groups of coincident points: 
- The first group starts at index 0 and includes (3 - 0) = 3 points: 0,3,4.
- The second group starts at index 3 and includes (5 - 3) = 2 points: 1,2.

\anchor cpp_mcdataarraydouble_meldwith
<br><h2> Concatenating DataArrayDouble's by appending components </h2>

In this example we create two data arrays including \b same number of
tuples and then we concatenate them using \ref
ParaMEDMEM::DataArrayDouble::meldWith "meldWith()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayDouble_Meld1_1
Now the array \b da1 includes 7 tuples (as before) of 3 components
each. Its components are: "c0da1","c1da1","c0da2".


\anchor cpp_mcdataarrayint_meldwith
<br><h2> Concatenating DataArrayInt's by appending components </h2>

In this example we create two data arrays including \b same number of
tuples and then we concatenate them using \ref
ParaMEDMEM::DataArrayInt::meldWith "meldWith()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayInt_Meld1_1
Now the array \b da1 includes 7 tuples (as before) of 3 components
each. Its components are: "c0da1","c1da1","c0da2".


\anchor cpp_mcdataarraydouble_KeepSelectedComponents

<br><h2>Creation of a sub-part of the DataArrayDouble by selecting components</h2>

\snippet MEDCouplingExamplesTest.py SnippeDataArrayDoubleKeepSelectedComponents1_1
We created an array \b a1 containing 5 tuples of 4 components each (20
values). Now we are going to create an array \b a2 containing some
components of \b a1.
\snippet MEDCouplingExamplesTest.py SnippeDataArrayDoubleKeepSelectedComponents1_2
Now each tuple of \b a2 includes components named "b","c","b","c","a","a". Thus
the result array \b a2 includes 30 elements (5 tuples per 6 components).


\anchor cpp_mcdataarrayint_keepselectedcomponents

<br><h2>Creation of a sub-part of the DataArrayInt by selecting components</h2>

\snippet MEDCouplingExamplesTest.py SnippeDataArrayIntKeepSelectedComponents1_1
We created an array \b a1 containing 5 tuples of 4 components each (20
values). Now we are going to create an array \b a2 containing some
components of \b a1.
\snippet MEDCouplingExamplesTest.py SnippeDataArrayIntKeepSelectedComponents1_2
Now each tuple of \b a2 includes components named "b","c","b","c","a","a". Thus
the result array \b a2 includes 30 elements (5 tuples per 6 components).

Note that
\ref ParaMEDMEM::DataArrayInt::keepSelectedComponents() "DataArrayInt::keepSelectedComponents()" 
is called, providing the same result, by the following python code:
\snippet MEDCouplingExamplesTest.py SnippeDataArrayIntKeepSelectedComponents1_3

\anchor cpp_mcfielddouble_subpart1


<br><h2>Creation of a sub part of a field</h2>
<br><h3>Creation of a sub part of a field on cells</h3>
\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuildSubPart1_1
The field on cells \b f1 lies on a mesh containing 5 cells and 9 nodes.		
So this field \b f1 contains 5 tuples of 2 components each (10 values).
Now let's create a subfield on cells \b f2 from \b f1.
\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuildSubPart1_2

\b f1 is a field on cells, \ref ParaMEDMEM::MEDCouplingFieldDouble::buildSubPart "buildSubPart" method performs an extraction on cells too.

So the array \b part1 lists ids on cells.

- cell #0 of \b f2 is the same cell of cell #2 of \b f1
- cell #1 of \b f2 is the same cell of cell #1 of \b f1
- cell #2 of \b f2 is the same cell of cell #4 of \b f1

So \b f2 contains 3 tuples with 2 components.

The underlying mesh of \b f2 contains a newly created mesh with 3 cells (not as \b mesh1 in \b f1) and 9 nodes (as \b mesh1 in \b f1).
\n For fields on cells the number of tuples of the returned field is always equal to the number of ids given in input (here \b part1).
\nOnly fields on cells have this particular behaviour.

<br><h3>Creation of a sub part of a field on nodes</h3>
\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuildSubPart1_3
The field on nodes \b f1 lies on a mesh containing 5 cells and 9 nodes.
So this field \b f1 contains 9 tuples of 2 components each (18 values).
Now let's create a subfield on nodes \b f2 from \b f1.
\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuildSubPart1_4

\b f1 is a field on nodes, but \ref ParaMEDMEM::MEDCouplingFieldDouble::buildSubPart "buildSubPart" method performs an extraction on \b cells.

After the call of \ref ParaMEDMEM::MEDCouplingFieldDouble::buildSubPart "buildSubPart" on node field \b f1, \b f1 will be reduced on a
submesh of \b mesh1 containing cells whoses ids are in \b part2. So here the number of cells of \b f2 is 2 and the number of nodes is 4.
\nSo contrary to fields on cells, it is normal for fields on nodes that number of tuples of the returned field of \ref ParaMEDMEM::MEDCouplingFieldDouble::buildSubPart "buildSubPart" 
method does not match the size of the input array (here \b part2).

*/

/*!
\page medcouplingcppexamplesUmeshStdBuild1 <br><h1> Example of standard build of an unstructured mesh from scratch in C++ </h1>

Firstly retrieve basic data in full interlace mode for coordinates, and nodal connectivity cell per cell.
\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_1

Then create ParaMEDMEM::MEDCouplingUMesh instance giving its meshdimension (2 here) and a name.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_2

Gives an upper bound of the number of cells to be inserted into the unstructured mesh.
\n Then enter nodal connectivity of all cells, cell per cell using ParaMEDMEM::MEDCouplingUMesh::insertNextCell method.
\n When the nodal connectivity cell per cell has been finished, call ParaMEDMEM::MEDCouplingUMesh::finishInsertingCells method in order to restore \b mesh instance.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_3

At this level the connectivity part of the mesh \b mesh as been defined. Now let's set the coordinates using array \b coords defined above.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_4

At this level mesh is usable. When this mesh is no more needed simply call decrRef to decrement its reference counter.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_5

*/

/*!
\page medcouplingcppexamplesUmeshAdvBuild1 <br><h1> Example of advanced build of an unstructured mesh from scratch in C++ </h1>

Firstly retrieve basic data in full interlace mode for coordinates, and nodal connectivity cell per cell, cell type \b included (3 for INTERP_KERNEL::NORM_TRI3 and 4 for INTERP_KERNEL::QUAD4).
\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_1

Then create ParaMEDMEM::MEDCouplingUMesh instance giving its meshdimension (2 here) and a name.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_2

Then enter nodal connectivity at once.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_3

At this level the connectivity part of the mesh \b mesh as been defined. Now let's set the coordinates using array \b coords defined above.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_4

At this level mesh is usable. When this mesh is no more needed simply call decrRef() to decrement its reference counter.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_5

*/

/*!
\page medcouplingcppexamplesCmeshStdBuild1 <br><h1> Example of standard build of an cartesian mesh from scratch in C++ </h1>

We are going to build a 2D cartesian mesh, constituted from 9 nodes along X axis, and 7 nodes along Y axis.

Firstly retrieve for each direction the discretization and build a \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble instance" on the corresponding direction.

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_1

Then create ParaMEDMEM::MEDCouplingCMesh instance giving the 2 instances of \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" obtained above.

There are 2 techniques to get it.

Either :

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_2

Or :

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_2bis

\c mesh is now available for use :

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_3

When this mesh is no more needed simply call decrRef to decrement its reference counter.

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_4

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild1 <br><h1> Examples in C++ of standard build of a tensor field on cells with no time attached  </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild1_1

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild2 <br><h1> Examples in C++ of standard build of a scalar field on nodes with no time attached </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild2_1

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild3 <br><h1> Examples in C++ of standard build of a vector field on cells with with one time attached and no time interval </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild3_1

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild4 <br><h1> Examples in C++ of standard build of a vector field on nodes defined on a time interval with a constant value during this interval </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild4_1

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild5 <br><h1> Examples in C++ of operation that can be carried out on fields on cells </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild1_2

The decrementation of ref counter should be carried out in CPlusPlus only ...

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild1_3

*/
