/*!
\page medcouplingcppexamples MEDCoupling C++ examples


\anchor cpp_mcpointset_
<br><h2>  </h2>

\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_
\snippet MEDCouplingExamplesTest.py PySnippet_MEDCouplingPointSet_
\snippet MEDCouplingExamplesTest.py Snippet_MEDCouplingPointSet_


\anchor cpp_mcpointset_scale
<br><h2> Scaling the mesh </h2>

First, we create a 2D mesh with 4 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_scale_1
Then we scale it by a factor of 2 with a center (0.,0.).
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_scale_2
Finally we check that all node coordinates have changed by more than 0.9.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_scale_3




\anchor cpp_mcpointset_translate
<br><h2> Translating the mesh </h2>

First, we create a 2D mesh with 4 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_translate_1
Then we translate it by a vector (1.,1.).
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_translate_2
Finally we check that all node coordinates have changed by more than 0.9.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_translate_3



\anchor cpp_mcpointset_rotate
<br><h2> Rotating the mesh </h2>

First, we create a 2D mesh with 4 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_rotate_1
Then we rotate it around a point (0.,0.) by 90 degrees clockwise.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_rotate_2
Next, we make a 3D mesh from the 2D one and rotate it around the Z axis by 90 degrees
counter-clockwise. 
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_rotate_3
Finally we transform the mesh back to 2D space and check that all nodes get back to the
initial location.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_rotate_4

\anchor cpp_mcpointset_getBoundingBox
<br><h2> Getting a minimum box bounding nodes </h2>

First, we create a 3D mesh with 2 nodes, so that the first one has minimal coordinates and
the second one has maximal coordinates.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getBoundingBox_1
Now we get a bounding box enclosing these nodes. This bounding box should contain
coordinates of our two nodes (but in "no interlace" mode), as the nodes coincide with
points returned by the bounding box.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getBoundingBox_2


\anchor cpp_mcpointset_getnodeidsnearpoint
<br><h2> Getting nodes close to a point </h2>

The following code creates a 2D \ref ParaMEDMEM::MEDCouplingUMesh
"MEDCouplingUMesh" with 5 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getNodeIdsNearPoint_1
Now we define an array of coordinates of a point close to nodes #0, #2 and #4.

Thus we expect that 
\ref ParaMEDMEM::MEDCouplingPointSet::getNodeIdsNearPoint "getNodeIdsNearPoint()" that
we are going to use,
if called with \b eps = 0.003, would return ids of nodes #0, #2 and #4.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getNodeIdsNearPoint_2


\anchor cpp_mcpointset_getnodeidsnearpoints
<br><h2> Getting nodes close to some points </h2>

The following code creates a 2D \ref ParaMEDMEM::MEDCouplingUMesh
"MEDCouplingUMesh" with 7 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getNodeIdsNearPoints_1
Now we define an array of coordinates of 3 points near which we want to find nodes of the mesh.
- Point #0 is at distance 0.001 from the node #1.
- Point #1 is rather far from all nodes.
- Point #2 is close to nodes #3, #4 and #5.

Thus we expect that 
\ref ParaMEDMEM::MEDCouplingPointSet::getNodeIdsNearPoints "getNodeIdsNearPoints()" that
we are going to use,
if called with \b eps = 0.003, would return ids of close nodes #1, #3, #4 and #5.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getNodeIdsNearPoints_2
\b idsIndex returns [0, 1, 1, 4] which means that:
- Point #0 is close to 1 (== \b idsIndex[1] - \b idsIndex[0]) node whose id is 
\b ids[ \b idsIndex[ 0 ]].
- Point #1 is close to 0 (== \b idsIndex[2] - \b idsIndex[1]) nodes.
- Point #2 is close to 3 (== \b idsIndex[3] - \b idsIndex[2]) nodes whose ids are
\b ids[ \b idsIndex[ 2 ]], \b ids[ \b idsIndex[ 2 ] + 1 ] and \b ids[ \b idsIndex[ 2 ] + 2 ].


\anchor cpp_mcpointset_findcommonnodes
<br><h2> Finding coincident nodes </h2>

First, we create a mesh with 6 nodes, of which two nodes (#3 and #4) are fully coincident
and 3 nodes (#0, #2 and #5) have distance less than 0.004 between them.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_findCommonNodes_1
Then, we use \ref ParaMEDMEM::MEDCouplingPointSet::findCommonNodes() "findCommonNodes()" to find
coincident nodes, and check that (1) calling 
\ref ParaMEDMEM::MEDCouplingPointSet::findCommonNodes() "findCommonNodes()" with \b prec
== 1e-13 finds the two fully coincident nodes only and (2)
\ref ParaMEDMEM::MEDCouplingPointSet::findCommonNodes() "findCommonNodes"(0.004) finds 5
equal nodes.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_findCommonNodes_2

\anchor cpp_mcpointset_getcoordinatesofnode
<br><h2> Getting coordinates of a node </h2>

The following code creates a 2D \ref ParaMEDMEM::MEDCouplingUMesh
"MEDCouplingUMesh" with 3 nodes and no cells.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getCoordinatesOfNode_1
Here we get coordinates of the second node and check its two coordinates.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingPointSet_getCoordinatesOfNode_2

\anchor cpp_mcdataarrayint_getTuple
<br><h2> Getting a tuple of DataArrayInt </h2>

In this simple example we create an array of integers arranged into 3
tuples per 2 components, and finally print the second tuple.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_getTuple_1
The output is
<pre> [9, 10] </pre>
Note that we can traverse all tuples in the array by simply iterating
over it as the code below does.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_getTuple_2
Its output follows.
<pre>
(7, 8)
(9, 10)
(11, 12)
</pre>

\anchor cpp_mcdataarrayint_buildpermutationarr
<br><h2> Building a permutation array </h2>

Here we create two arrays containing same values but in different order and then we use
\ref ParaMEDMEM::DataArrayInt::buildPermutationArr "DataArrayInt::buildPermutationArr()" to get
an array showing in what places the values of \b b array are located in \b a array.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayInt_buildPermutationArr_1
The result array \b c contains [1,0,4,2,3].

<br><h2> Inverting renumbering maps </h2>
\anchor cpp_mcdataarrayint_invertarrayo2n2n2o
<h3> invertArrayO2N2N2O() </h3>

In this example we create a DataArrayInt containing a renumbering map in 
"Old to New" mode, convert it into the renumbering map in "New to Old" mode and check the
result.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayInt_invertArrayO2N2N2O_1

\anchor cpp_mcdataarrayint_invertarrayn2o2o2n
<br><h3> invertArrayN2O2O2N() </h3>

In this example we create a DataArrayInt containing a renumbering map in 
"New to Old" mode, convert it into the renumbering map in "Old to New" mode and check the
result.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayInt_invertArrayN2O2O2N_1



\anchor cpp_mcdataarraydouble_getidsinrange
<br><h2> Finding values in range in  DataArrayDouble</h2>

In this example we create an array \b da containing same values as ones returned by
\c range( \c 10 ). Then we get an array of indices of values of \b da being in
range [ 2.5, 6 ].
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayDouble_getIdsInRange_1
As result contents of the array \b da2 are as follows.
<pre>
    Tuple #0 : 3
    Tuple #1 : 4
    Tuple #2 : 5
    Tuple #3 : 6
</pre>


\anchor cpp_mcdataarraydouble_setselectedcomponents
<br><h2> Set part of values of DataArrayDouble </h2>
<h3> setSelectedComponents() </h3>
First, we create a 'source' array.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setSelectedComponents1
Now we create a larger zero array and assign the array \b da into it.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setSelectedComponents2
As result contents of the array \b dv are as follows.
<pre>
Info of components : "a2"   "a1"   "v3"   "v4"   
    Tuple #0 : 2 1 0 0 
    Tuple #1 : 4 3 0 0 
    Tuple #2 : 6 5 0 0 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way (except that component info
is not copied):
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setSelectedComponents3

\anchor cpp_mcdataarraydouble_setpartofvalues1
<br><h3> setPartOfValues1() </h3>
We create two arrays: 
- a "large" (4x4) zero array \b da to assign to and
- a smaller (2x2) array \b dv filled with values [7.,8.,9.,10].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_1
Now we copy \b dv to the middle of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_2
As result contents of the array \b da are as follows.
<pre>
    Info of components :"v1"   "v2"   "v3"   "v4"
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 8 0 
    Tuple #2 : 0 9 10 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and copy \b dv into a component of \b da.

Note that the last parameter \a strictCompoCompare should be \a False
in this case, else \ref ParaMEDMEM::DataArrayDouble::setPartOfValues1() 
throws an exception because \b da has 2 components but only one target
component is specified.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 8 0 0 
    Tuple #2 : 0 9 0 0 
    Tuple #3 : 0 10 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 8 9 10 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_5
<pre>
    Tuple #0 : 0 7 0 8 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 9 0 10 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way:
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues1_6



\anchor cpp_mcdataarraydouble_setpartofvaluessimple1
<br><h3> setPartOfValuesSimple1() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_1
Now we assign \b dv to the middle of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way:
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple1_6


\anchor cpp_mcdataarraydouble_setpartofvaluessimple2
<br><h3> setPartOfValuesSimple2() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_1
Now we assign \b dv to the middle of \b da.
We explicitly specify tuples and component to assign to by a list [1,2].
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple2_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
\note \ref ParaMEDMEM::DataArrayDouble::setPartOfValuesSimple2() can't
be explicitly called in Python.


\anchor cpp_mcdataarraydouble_setpartofvaluessimple3
<br><h3> setPartOfValuesSimple3() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_1
Now we assign \b dv to the middle of \b da.
We explicitly specify tuples to assign to by a list [1,2]. And we specify
components to assign to using slicing: 1:3.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValuesSimple3_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
\note \ref ParaMEDMEM::DataArrayDouble::setPartOfValuesSimple3() can't
be explicitly called in Python.


\anchor cpp_mcdataarraydouble_setpartofvalues2
<br><h3> setPartOfValues2() </h3>
We create two arrays: 
- a "large" (4x7) zero array \b da to assign to,
- a smaller (3x2) array \b dv filled with values [7.,8.,9.,10.,11.,12.].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues2_1
Now we assign the two components of \b dv to the components of \b da
with indices [1,3], and the 3 tuples of \b dv to the 3 tuples of \b da with
  indices [0,1,2]. This is the first mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues2_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0  7  0  8  0  0  0  
    Tuple #1 : 0  9  0 10  0  0  0 
    Tuple #2 : 0 11  0 12  0  0  0 
    Tuple #3 : 0  0  0  0  0  0  0
</pre>
Every value of \b dv has been assigned to its own location within \b da.

Now we re-fill \b da with zeros and rearrange \b dv to have 6 components.
And we assign \b dv to the tuples of \b da with indices [0,2,3] .
This is the second mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues2_3
The contents of \b dv have been assigned to each of specified tuples of \b da.
Every value of \b dv is repeated in the 3 specified tuples within \b da.
<pre>
    Tuple #0 : 7  0  8  9 10 11 12
    Tuple #1 : 0  0  0  0  0  0  0   
    Tuple #2 : 7  0  8  9 10 11 12
    Tuple #3 : 7  0  8  9 10 11 12
</pre>
\note \ref ParaMEDMEM::DataArrayDouble::setPartOfValues2() can't
be explicitly called in Python.


\anchor cpp_mcdataarraydouble_setpartofvalues3
<br><h3> setPartOfValues3() </h3>
We create two arrays: 
- a "large" (4x7) zero array \b da to assign to,
- a smaller (3x2) array \b dv filled with values [7.,8.,9.,10.,11.,12.].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues3_1
Now we assign the two components of \b dv to the components of \b da
with indices [1,3], and the 3 tuples of \b dv to the 3 tuples of \b da with
indices [0,1,2] which are specified using slicing: "0:3". 
This is the first mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues3_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0  7  0  8  0  0  0  
    Tuple #1 : 0  9  0 10  0  0  0 
    Tuple #2 : 0 11  0 12  0  0  0 
    Tuple #3 : 0  0  0  0  0  0  0
</pre>
Every value of \b dv has been assigned to its own location within \b da.

Now we re-fill \b da with zeros and rearrange \b dv to have 6 components.
And we assign \b dv to the tuples of \b da with indices [0,2] using \a
slice notation "0:4:2". This is the second mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_setPartOfValues3_3
The contents of \b dv have been assigned to each of specified tuples of \b da.
Every value of \b dv is repeated in the 3 specified tuples within \b da.
<pre>
    Tuple #0 : 7  0  8  9 10 11 12
    Tuple #1 : 0  0  0  0  0  0  0   
    Tuple #2 : 7  0  8  9 10 11 12
    Tuple #3 : 0  0  0  0  0  0  0   
</pre>
\note \ref ParaMEDMEM::DataArrayDouble::setPartOfValues3() can't
be explicitly called in Python.


\anchor cpp_mcdataarrayint_setselectedcomponents
<br><h2> Set part of values of DataArrayInt </h2>
<h3> setSelectedComponents() </h3>
First, we create a 'source' array.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setSelectedComponents1
Now we create a larger zero array and assign the array \b da to it.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setSelectedComponents2
As result contents of the array \b dv are as follows.
<pre>
Info of components : "a2"   "a1"   "v3"   "v4"   
    Tuple #0 : 2 1 0 0 
    Tuple #1 : 4 3 0 0 
    Tuple #2 : 6 5 0 0 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way (except that component info
is not copied):
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setSelectedComponents3

\anchor cpp_mcdataarrayint_setpartofvalues1
<br><h3> setPartOfValues1() </h3>
We create two arrays: 
- a "large" (4x4) zero array \b da to assign to and
- a smaller (2x2) array \b dv filled with values [7,8,9,10].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_1
Now we copy \b dv to the middle of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_2
As result contents of the array \b da are as follows.
<pre>
    Info of components :"v1"   "v2"   "v3"   "v4"
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 8 0 
    Tuple #2 : 0 9 10 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and copy \b dv into a component of \b da.

Note that the last parameter \a strictCompoCompare should be \a False
in this case, else \ref ParaMEDMEM::DataArrayInt::setPartOfValues1() 
throws an exception because \b da has 2 components but only one target
component is specified.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 8 0 0 
    Tuple #2 : 0 9 0 0 
    Tuple #3 : 0 10 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 8 9 10 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_5
<pre>
    Tuple #0 : 0 7 0 8 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 9 0 10 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way:
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues1_6



\anchor cpp_mcdataarrayint_setpartofvaluessimple1
<br><h3> setPartOfValuesSimple1() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_1
Now we assign \b dv to the middle of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
The same result can be achieved other way:
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple1_6


\anchor cpp_mcdataarrayint_setpartofvaluessimple2
<br><h3> setPartOfValuesSimple2() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_1
Now we assign \b dv to the middle of \b da.
We explicitly specify tuples and component to assign to by a list [1,2].
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple2_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
\note \ref ParaMEDMEM::DataArrayInt::setPartOfValuesSimple2() can't
be explicitly called in Python.


\anchor cpp_mcdataarrayint_setpartofvaluessimple3
<br><h3> setPartOfValuesSimple3() </h3>
We create an array (4x4) \b da to assign to and define a value \b dv to assign.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_1
Now we assign \b dv to the middle of \b da.
We explicitly specify tuples to assign to by a list [1,2]. And we specify
components to assign to using slicing: 1:3.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 0 7 7 0 
    Tuple #2 : 0 7 7 0 
    Tuple #3 : 0 0 0 0 
</pre>

Here we re-fill \b da with zeros and assign \b dv to a component of \b da.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_3
<pre>
    Tuple #0 : 0 7 0 0 
    Tuple #1 : 0 7 0 0 
    Tuple #2 : 0 7 0 0 
    Tuple #3 : 0 7 0 0 
</pre>
Below more two variants of location of target values are shown.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_4
<pre>
    Tuple #0 : 0 0 0 0 
    Tuple #1 : 7 7 7 7 
    Tuple #2 : 0 0 0 0 
    Tuple #3 : 0 0 0 0 
</pre>

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValuesSimple3_5
<pre>
    Tuple #0 : 0 7 0 7 
    Tuple #1 : 0 0 0 0 
    Tuple #2 : 0 7 0 7 
    Tuple #3 : 0 0 0 0 
</pre>
\note \ref ParaMEDMEM::DataArrayInt::setPartOfValuesSimple3() can't
be explicitly called in Python.


\anchor cpp_mcdataarrayint_setpartofvalues2
<br><h3> setPartOfValues2() </h3>
We create two arrays: 
- a "large" (4x7) zero array \b da to assign to,
- a smaller (3x2) array \b dv filled with values [7,8,9,10,11,12].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues2_1
Now we assign the two components of \b dv to the components of \b da
with indices [1,3], and the 3 tuples of \b dv to the 3 tuples of \b da with
  indices [0,1,2]. This is the first mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues2_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0  7  0  8  0  0  0  
    Tuple #1 : 0  9  0 10  0  0  0 
    Tuple #2 : 0 11  0 12  0  0  0 
    Tuple #3 : 0  0  0  0  0  0  0
</pre>
Every value of \b dv has been assigned to its own location within \b da.

Now we re-fill \b da with zeros and rearrange \b dv to have 6 components.
And we assign \b dv to the tuples of \b da with indices [0,2,3] .
This is the second mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues2_3
The contents of \b dv have been assigned to each of specified tuples of \b da.
Every value of \b dv is repeated in the 3 specified tuples within \b da.
<pre>
    Tuple #0 : 7  0  8  9 10 11 12
    Tuple #1 : 0  0  0  0  0  0  0   
    Tuple #2 : 7  0  8  9 10 11 12
    Tuple #3 : 7  0  8  9 10 11 12
</pre>
\note \ref ParaMEDMEM::DataArrayInt::setPartOfValues2() can't
be explicitly called in Python.


\anchor cpp_mcdataarrayint_setpartofvalues3
<br><h3> setPartOfValues3() </h3>
We create two arrays: 
- a "large" (4x7) zero array \b da to assign to,
- a smaller (3x2) array \b dv filled with values [7,8,9,10,11,12].

\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues3_1
Now we assign the two components of \b dv to the components of \b da
with indices [1,3], and the 3 tuples of \b dv to the 3 tuples of \b da with
indices [0,1,2] which are specified using slicing: "0:3". 
This is the first mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues3_2
As result contents of the array \b da are as follows.
<pre>
    Tuple #0 : 0  7  0  8  0  0  0  
    Tuple #1 : 0  9  0 10  0  0  0 
    Tuple #2 : 0 11  0 12  0  0  0 
    Tuple #3 : 0  0  0  0  0  0  0
</pre>
Every value of \b dv has been assigned to its own location within \b da.

Now we re-fill \b da with zeros and rearrange \b dv to have 6 components.
And we assign \b dv to the tuples of \b da with indices [0,2] using \a
slice notation "0:4:2". This is the second mode of usage.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayInt_setPartOfValues3_3
The contents of \b dv have been assigned to each of specified tuples of \b da.
Every value of \b dv is repeated in the 3 specified tuples within \b da.
<pre>
    Tuple #0 : 7  0  8  9 10 11 12
    Tuple #1 : 0  0  0  0  0  0  0   
    Tuple #2 : 7  0  8  9 10 11 12
    Tuple #3 : 0  0  0  0  0  0  0   
</pre>
\note \ref ParaMEDMEM::DataArrayInt::setPartOfValues3() can't
be explicitly called in Python.


\anchor cpp_mcdataarraydouble_getdifferentvalues
<br><h2> Excluding coincident tuples from DataArrayDouble</h2>

The code below creates an array of real values and than an array of
  unique values, not closer one to another than 0.2, is retrieved from it.
\snippet MEDCouplingExamplesTest.py Snippet_DataArrayDouble_getDifferentValues1


\anchor cpp_mcdataarraydouble_findcommontuples
<br><h2> Finding coincident tuples in DataArrayDouble</h2>

Let's create an array of 6 tuples and 2 components that can be
  considered as coordinates of 6 points in 2D space.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayDouble_findCommonTuples1
Now we find points that are not far each from other than 1e-1.
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayDouble_findCommonTuples2
As we can realize from the above code, a hardcoded array \b expected3 is equal
  to the raw data of a DataArrayInt \b c and a hardcoded array \b expected4 is equal
  to the raw data of the DataArrayInt \b cI.

The array \b c contains indices of 5 coincident points. The array \b
  cI shows us boundaries of (cI->getNumberOfTuples()-1) = 2 groups of coincident points: 
- The first group starts at index 0 and includes (3 - 0) = 3 points: 0,3,4.
- The second group starts at index 3 and includes (5 - 3) = 2 points: 1,2.

\anchor cpp_mcdataarraydouble_meldwith
<br><h2> Concatenating DataArrayDouble's by appending components </h2>

In this example we create two data arrays including \b same number of
tuples and then we concatenate them using \ref
ParaMEDMEM::DataArrayDouble::meldWith "meldWith()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayDouble_Meld1_1
Now the array \b da1 includes 7 tuples (as before) of 3 components
each. Its components are: "c0da1","c1da1","c0da2".


\anchor cpp_mcdataarrayint_meldwith
<br><h2> Concatenating DataArrayInt's by appending components </h2>

In this example we create two data arrays including \b same number of
tuples and then we concatenate them using \ref
ParaMEDMEM::DataArrayInt::meldWith "meldWith()".
\snippet MEDCouplingExamplesTest.cxx CppSnippet_DataArrayInt_Meld1_1
Now the array \b da1 includes 7 tuples (as before) of 3 components
each. Its components are: "c0da1","c1da1","c0da2".


\anchor cpp_mcdataarraydouble_KeepSelectedComponents

<br><h2>Creation of a sub-part of the DataArrayDouble by selecting components</h2>

\snippet MEDCouplingExamplesTest.py SnippeDataArrayDoubleKeepSelectedComponents1_1
We created an array \b a1 containing 5 tuples of 4 components each (20
values). Now we are going to create an array \b a2 containing some
components of \b a1.
\snippet MEDCouplingExamplesTest.py SnippeDataArrayDoubleKeepSelectedComponents1_2
Now each tuple of \b a2 includes components named "b","c","b","c","a","a". Thus
the result array \b a2 includes 30 elements (5 tuples per 6 components).

\anchor cpp_mcfielddouble_subpart1

\anchor cpp_mcdataarrayint_keepselectedcomponents

<br><h2>Creation of a sub-part of the DataArrayInt by selecting components</h2>

\snippet MEDCouplingExamplesTest.py SnippeDataArrayIntKeepSelectedComponents1_1
We created an array \b a1 containing 5 tuples of 4 components each (20
values). Now we are going to create an array \b a2 containing some
components of \b a1.
\snippet MEDCouplingExamplesTest.py SnippeDataArrayIntKeepSelectedComponents1_2
Now each tuple of \b a2 includes components named "b","c","b","c","a","a". Thus
the result array \b a2 includes 30 elements (5 tuples per 6 components).

Note that
\ref ParaMEDMEM::DataArrayInt::keepSelectedComponents() "DataArrayInt::keepSelectedComponents()" 
is called, providing the same result, by the following python code:
\snippet MEDCouplingExamplesTest.py SnippeDataArrayIntKeepSelectedComponents1_3

\anchor cpp_mcfielddouble_subpart1


<br><h2>Creation of a sub part of a field</h2>
<br><h3>Creation of a sub part of a field on cells</h3>
\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuildSubPart1_1
The field on cells \b f1 lies on a mesh containing 5 cells and 9 nodes.		
So this field \b f1 contains 5 tuples of 2 components each (10 values).
Now let's create a subfield on cells \b f2 from \b f1.
\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuildSubPart1_2

\b f1 is a field on cells, \ref ParaMEDMEM::MEDCouplingFieldDouble::buildSubPart "buildSubPart" method performs an extraction on cells too.

So the array \b part1 lists ids on cells.

- cell #0 of \b f2 is the same cell of cell #2 of \b f1
- cell #1 of \b f2 is the same cell of cell #1 of \b f1
- cell #2 of \b f2 is the same cell of cell #4 of \b f1

So \b f2 contains 3 tuples with 2 components.

The underlying mesh of \b f2 contains a newly created mesh with 3 cells (not as \b mesh1 in \b f1) and 9 nodes (as \b mesh1 in \b f1).
\n For fields on cells the number of tuples of the returned field is always equal to the number of ids given in input (here \b part1).
\nOnly fields on cells have this particular behaviour.

<br><h3>Creation of a sub part of a field on nodes</h3>
\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuildSubPart1_3
The field on nodes \b f1 lies on a mesh containing 5 cells and 9 nodes.
So this field \b f1 contains 9 tuples of 2 components each (18 values).
Now let's create a subfield on nodes \b f2 from \b f1.
\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuildSubPart1_4

\b f1 is a field on nodes, but \ref ParaMEDMEM::MEDCouplingFieldDouble::buildSubPart "buildSubPart" method performs an extraction on \b cells.

After the call of \ref ParaMEDMEM::MEDCouplingFieldDouble::buildSubPart "buildSubPart" on node field \b f1, \b f1 will be reduced on a
submesh of \b mesh1 containing cells whoses ids are in \b part2. So here the number of cells of \b f2 is 2 and the number of nodes is 4.
\nSo contrary to fields on cells, it is normal for fields on nodes that number of tuples of the returned field of \ref ParaMEDMEM::MEDCouplingFieldDouble::buildSubPart "buildSubPart" 
method does not match the size of the input array (here \b part2).

*/

/*!
\page medcouplingcppexamplesUmeshStdBuild1 <br><h1> Example of standard build of an unstructured mesh from scratch in C++ </h1>

Firstly retrieve basic data in full interlace mode for coordinates, and nodal connectivity cell per cell.
\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_1

Then create ParaMEDMEM::MEDCouplingUMesh instance giving its meshdimension (2 here) and a name.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_2

Gives an upper bound of the number of cells to be inserted into the unstructured mesh.
\n Then enter nodal connectivity of all cells, cell per cell using ParaMEDMEM::MEDCouplingUMesh::insertNextCell method.
\n When the nodal connectivity cell per cell has been finished, call ParaMEDMEM::MEDCouplingUMesh::finishInsertingCells method in order to restore \b mesh instance.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_3

At this level the connectivity part of the mesh \b mesh as been defined. Now let's set the coordinates using array \b coords defined above.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_4

At this level mesh is usable. When this mesh is no more needed simply call decrRef to decrement its reference counter.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshStdBuild1_5

*/

/*!
\page medcouplingcppexamplesUmeshAdvBuild1 <br><h1> Example of advanced build of an unstructured mesh from scratch in C++ </h1>

Firstly retrieve basic data in full interlace mode for coordinates, and nodal connectivity cell per cell, cell type \b included (3 for INTERP_KERNEL::NORM_TRI3 and 4 for INTERP_KERNEL::QUAD4).
\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_1

Then create ParaMEDMEM::MEDCouplingUMesh instance giving its meshdimension (2 here) and a name.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_2

Then enter nodal connectivity at once.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_3

At this level the connectivity part of the mesh \b mesh as been defined. Now let's set the coordinates using array \b coords defined above.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_4

At this level mesh is usable. When this mesh is no more needed simply call decrRef() to decrement its reference counter.

\snippet MEDCouplingExamplesTest.cxx CppSnippetUMeshAdvBuild1_5

*/

/*!
\page medcouplingcppexamplesCmeshStdBuild1 <br><h1> Example of standard build of an cartesian mesh from scratch in C++ </h1>

We are going to build a 2D cartesian mesh, constituted from 9 nodes along X axis, and 7 nodes along Y axis.

Firstly retrieve for each direction the discretization and build a \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble instance" on the corresponding direction.

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_1

Then create ParaMEDMEM::MEDCouplingCMesh instance giving the 2 instances of \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" obtained above.

There are 2 techniques to get it.

Either :

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_2

Or :

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_2bis

\c mesh is now available for use :

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_3

When this mesh is no more needed simply call decrRef to decrement its reference counter.

\snippet MEDCouplingExamplesTest.cxx CppSnippetCMeshStdBuild1_4

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild1 <br><h1> Examples in C++ of standard build of a tensor field on cells with no time attached  </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild1_1

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild2 <br><h1> Examples in C++ of standard build of a scalar field on nodes with no time attached </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild2_1

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild3 <br><h1> Examples in C++ of standard build of a vector field on cells with with one time attached and no time interval </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild3_1

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild4 <br><h1> Examples in C++ of standard build of a vector field on nodes defined on a time interval with a constant value during this interval </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild4_1

*/

/*!
\page medcouplingcppexamplesFieldDoubleBuild5 <br><h1> Examples in C++ of operation that can be carried out on fields on cells </h1>

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild1_2

The decrementation of ref counter should be carried out in CPlusPlus only ...

\snippet MEDCouplingExamplesTest.cxx CppSnippetFieldDoubleBuild1_3

*/
