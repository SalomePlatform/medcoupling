/*!
\page medcoupling MEDCoupling

\section MEDCouplingIntro Introduction

\ref medcoupling "MEDCoupling" is a library (\b libmedcoupling.so or \b medcoupling.dll) fully written in C++ and wrapped to be called in Python too.

\ref medcoupling "MEDCoupling" C++ library implements a data structure which is the result of the following tradeoff :

- Compliant with coupling :
  - Fields definition defined enough to perform well defined interpolation
  - exchangeable through process as well in parallel case in SPMD paradigm ( \ref paramedmem "ParaMEDMEM" ), as in distributed paradigm using CORBA.
- minimize as much as possible the number of prerequisites needed to use it ; So \ref medcoupling "MEDCoupling" only depends from
\ref interpkernel "INTERP_KERNEL library"
- light enough to be agile in order to :
   - maximize the amount of algorithms being applied on it
   - to ease implementation of clients of \ref medcoupling "MEDCoupling".
- large enough to be used for MED file I/O.
- compliant with VTK visualization DataStructure
- integrate HPC constraints (compact structures, limitation of copies and launching of CPU consuming algorithms only when absolutely needed ).
- compliant with ICOCO API

The \ref medcoupling "MEDCoupling" data structure is \b fully \b independant from those implemented in MEDMEM.

\ref medcoupling "MEDCoupling" implements a set of algorithms linked to the data structure.

\section MEDCouplingMainConc Main Concepts

Here are listed basic concepts present into \ref medcoupling "MEDCoupling".

For beginners in \ref medcoupling "MEDCoupling" world, it is advisable to read the following concepts in the same order than the underlying list.

- \subpage MEDCouplingArrayPage "DataArrays"
- \subpage MEDCouplingMeshesPage "Meshes"
- \subpage MEDCouplingFieldsPage "Fields"
- \subpage MEDCouplingFieldTemplatesPage "Field templates"

*/

/*!
  \page MEDCouplingMeshesPage Meshes in MEDCoupling

\section MEDCouplingMeshes Common concept shared by all type of Meshes in MEDCoupling

A mesh has a the following properties :

- name
- a dimension (called mesh dimension) and only one (it implies that \b all cells constituting
mesh have the same dimension)
- a space dimension (relative to coordinates)
- a number of nodes
- a number of cells

In MEDCoupling library there is no presence of faces nor edges.

As a mesh has one dimension and only once, that is to say every cells in
mesh have the same dimension called MeshDimension.

That is to say the
MEDMEM vocabulary of faces and edges \b do \b not \b exist \b anymore here in
MEDCoupling.

For exemple a mesh with a meshDimension equal to 1, have \b cells of type
NORM_SEG2. An another exemple, a mesh with a meshDimension equal
to 2, have \b cells of type
NORM_TRI3 and NORM_POLYGON for example.

The class that incarnates the concept described above is :
\ref ParaMEDMEM::MEDCouplingMesh.

\section MEDCouplingMeshesAvailInstan Available instaciable mesh types in MEDCoupling

- \subpage MEDCouplingUMeshPage "Unstructured meshes"
- \subpage MEDCouplingCMeshPage "Cartesian meshes"
- \subpage MEDCouplingExtrudedPage "3D Extruded meshes"

/*!
\page MEDCouplingFieldsPage Fields in MEDCoupling

\section MEDCouplingFields Field concept

A field in MEDCoupling point of view, is a structure that allows to
store a discretization of a physical value on a defined discretized spatial and
possibly temporal support.

The spatial support is a \ref MEDCouplingMeshesPage "mesh".
A field is lying on an entity that will be specified by the spatial
discretization of the field. For exemple a field on node will lie on
all nodes of its mesh.

A field on cell will lie on all cells of its mesh.

Fields in MEDCoupling follow the two following rules :

- A field will lie on \b ALL entities of its spatial support (\ref MEDCouplingMeshesPage "mesh").
- A field has \b only \b one spatial support (\ref MEDCouplingMeshesPage "mesh") on its temporal support.

The main properties of a field are :

- name
- spatial support which is a \ref MEDCouplingMeshesPage "mesh"
- a \ref MEDCouplingSpatialDisc "spatial discretization"
- a description of intrinsic nature of the values of field (see \ref NatureOfField). This is important for conservative interpolation (see \ref TableNatureOfField).
- a temporal discretization that specifies, if it exists, the time interval on which the field is covering, and how.
- number of components

This definition of field in MEDCoupling allows an instance of field to
know at any point inside its spatial-temporal support the value.

The class that incarnates the concept described above is : \ref ParaMEDMEM::MEDCouplingFieldDouble.

Some of most important implemented methods are :

- \ref ParaMEDMEM::MEDCouplingFieldDouble::getNumberOfComponents "getNumberOfComponents"
- \ref ParaMEDMEM::MEDCouplingFieldDouble::getValueOn "getValueOn"
- \ref ParaMEDMEM::MEDCouplingFieldDouble::applyFunc "applyFunc"
- \ref ParaMEDMEM::MEDCouplingFieldDouble::addFields "cross instances operations"
\section MEDCouplingSpatialDisc Spatial discretization concept

This is the concept that makes the link, independantly from temporal
discretization, between the field and its spatial support(\ref MEDCouplingMeshesPage "mesh"). This
concept allows the field to make a check and interpretation of an
array of values given a spatial support (\ref MEDCouplingMeshesPage "mesh").

The abstract class that incarnates the concept is : \ref ParaMEDMEM::MEDCouplingFieldDiscretization.

The most important pure virtual methods are :

- \ref ParaMEDMEM::MEDCouplingFieldDiscretization::getNumberOfTuples "getnumberOfTuples"
- \ref ParaMEDMEM::MEDCouplingFieldDiscretization::getValueOn "getValueOn"
- \ref ParaMEDMEM::MEDCouplingFieldDiscretization::getMeasureField "getMeasureField"

\section MEDCouplingTemporalDisc Temporal discretization concept

This information allows, independantly from spatial discretization, to
associate a time interval, if it exists, on which the field will be
defined. This concept is able to give the value at any time of
the definition interval (if any).

The abstract class \ref ParaMEDMEM::MEDCouplingTimeDiscretization
incarnates this described concept.

This classes and its subclasses are responsible in storing the arrays
of the aggregating field.

The most important methods are :

- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::setTime "setTime" and \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getTime "getTime"
- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getArray "getArray" and \ref ParaMEDMEM::MEDCouplingTimeDiscretization::setArray "setArray"
- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getArraysForTime "getArraysForTime"
- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getValueForTime "getValueForTime"

\section MEDCouplingFirstSteps3 Building a field from scratch

All of exemples given here make the assumption that the \c ParaMEDMEM
namespace is visible ( by calling for example \c using \c
namespace \c ParaMEDMEM; ).

Here we will make the assumption that an instance of \c MEDCouplingMesh
called \c mesh has been created.

- create a tensor field with 9 components on cells with no time step
\code
MEDCouplingFieldDouble* fieldOnCells=MEDCouplingFieldDouble::New(ON_CELLS,NO_TIME);
fieldOnCells->setName("MyTensorFieldOnCellNoTime");
fieldOnCells->setMesh(mesh);
DataArrayDouble *array=DataArrayDouble::New();
array->alloc(mesh->getNumberOfCells(),9);//Implicitely fieldOnCells will be a 9 components field.
fieldOnCells->setArray(array);
tmp=array->getPointer();
std::fill(tmp,tmp+9*mesh->getNumberOfCells(),7.);
array->declareAsNew();
array->decrRef();
//fieldOnCells is now usable
...
//fieldOnCells is no more usefully here : release it
fieldOnCells->decrRef();
\endcode
- create a scalar field on nodes with no time step
\code
MEDCouplingFieldDouble* fieldOnNodes=MEDCouplingFieldDouble::New(ON_NODES,NO_TIME);
fieldOnNodes->setName("MyScalarFieldOnNodeNoTime");
fieldOnNodes->setMesh(mesh);
DataArrayDouble *array=DataArrayDouble::New();
array->alloc(mesh->getNumberOfNodes(),1);//Implicitely fieldOnNodes will be a scalar field.
fieldOnNodes->setArray(array);
tmp=array->getPointer();
std::fill(tmp,tmp+mesh->getNumberOfNodes(),7.);
array->declareAsNew();
array->decrRef();
//fieldOnNodes is now usable
...
//fieldOnNodes is no more usefully here : release it
fieldOnNodes->decrRef();
\endcode
- create a 2 components-vector field on cells with one time step and no interval
\code
MEDCouplingFieldDouble* fieldOnCells=MEDCouplingFieldDouble::New(ON_CELLS,ONE_TIME);
fieldOnCells->setName("MyVecFieldOnCellWithTime");
fieldOnCells->setMesh(mesh);
fieldOnCells->setTime(4.22,2,-1);
DataArrayDouble *array=DataArrayDouble::New();
array->alloc(mesh->getNumberOfCells(),2);//Implicitely fieldOnCells will be a 2 components field.
fieldOnCells->setArray(array);
tmp=array->getPointer();
std::fill(tmp,tmp+2*mesh->getNumberOfCells(),7.);
array->declareAsNew();
array->decrRef();
//fieldOnCells is now usable
...
//fieldOnCells is no more usefully here : release it
fieldOnCells->decrRef();
\endcode
- create a 3 components-vector field on nodes with a time interval where hied is constant
\code
MEDCouplingFieldDouble* fieldOnNodes=MEDCouplingFieldDouble::New(ON_NODES,CONST_ON_TIME_INTERVAL);
fieldOnNodes->setName("MyVecFieldOnNodeWithConstTime");
fieldOnNodes->setMesh(mesh);
fieldOnNodes->setStartTime(4.22,2,-1);
fieldOnNodes->setEndTime(6.44,4,-1);
DataArrayDouble *array=DataArrayDouble::New();
array->alloc(mesh->getNumberOfNodes(),3);//Implicitely fieldOnNodes will be a 3 components field.
fieldOnNodes->setArray(array);
tmp=array->getPointer();
std::fill(tmp,tmp+3*mesh->getNumberOfNodes(),7.);
array->declareAsNew();
array->decrRef();
//fieldOnNodes is now usable
...
//fieldOnNodes is no more usefully here : release it
fieldOnNodes->decrRef();
\endcode

\section MEDCouplingSecondStep0 Operations on Fields
Here we will make the assumption that an instance of \ref ParaMEDMEM::MEDCouplingMesh "MEDCouplingMesh"
called \c mesh has been created with spaceDim==2.
Here some exemple of more advanced use of \ref ParaMEDMEM::MEDCouplingFieldDouble "MEDCouplingFieldDouble".
\code
MEDCouplingFieldDouble *f1=mesh->fillFromAnalytic(ON_NODES,1,"x*x+y*y*3+2.*x");//f1 is scalar
MEDCouplingFieldDouble *f2=mesh->fillFromAnalytic(ON_NODES,1,"cos(x+y/x)");//f2 is scalar too
MEDCouplingFieldDouble *f2bis=mesh->fillFromAnalytic(ON_NODES,2,"x*x*IVec+3*y*JVec");//f2bis is a vectors field
MEDCouplingFieldDouble *f3=(*f1)+(*f2);//f3 scalar
MEDCouplingFieldDouble *f4=(*f3)/(*f2);//f4 scalar
f2bis->applyFunc(1,"sqrt(x*x+y*y)");//f2bis becomes scalar
MEDCouplingFieldDouble *f5=(*f2bis)*(*f4);//f5 scalar
const double pos1[2]={0.25,0.};
double res;
f4->getValueOn(pos1,&res);//f4 is scalar so the returned value is of size 1.
//
...
//f1, f2, f2bis, f3, f4, f5 are no more usefully here : release them
f1->decrRef();
f2->decrRef();
f2bis->decrRef();
f3->decrRef();
f4->decrRef();
f5->decrRef();
\endcode

*/

/*!
\page MEDCouplingArrayPage MEDCoupling Arrays

\section MEDCouplingArrayIntro Introduction

One of the most basic concept mainly used all over MEDCoupling is
MEDCoupling array.

This concept is used all over
\ref medcoupling "MEDCoupling", \ref paramedmem "ParaMEDMEM", \ref medloader "MEDLoader" modules so it should be correctly
handled to play well with \ref MEDCouplingMeshesPage "Meshes" and \ref MEDCouplingFieldsPage "Fields".

There are for the moment two types of arrays :
 - double precision float (64 bits) array incarnated by ParaMEDMEM::DataArrayDouble class.
 - signed integer (32 bits) array incarnated by ParaMEDMEM::DataArrayInt class.

\section MEDCouplingArrayBasics Basics concepts

It will be presented in this section common concept shared by the two classes to \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" and \ref ParaMEDMEM::DataArrayInt "DataArrayInt".

- The first thing is that an array has a name (stored as a C++ string). This name is often ignored in MEDCoupling algorithm when arrays are aggregated (field array, connectivity, coordinates).
  The reason is that name is stored by the aggregating object.
  But it can be very usefull for arrays not aggregated in bigger MEDCoupling object for groups ids and families ids for example.

- The second thing is the data storage. For obvious reason, MEDCoupling DataArray stores data in a contiguous way in memory like \c std::vector does.\n

- The third thing is linked to previous point. Data arrays are able to store vectorized data. It is usefull to store the data of a vectorial field. That's why MEDCoupling arrays uses the concepts
  of components. To store an array for a vector field on cell with 3 components lying on a mesh having 5 cells. The array will contain 5*3=15 values grouped by 3.
  The 5 groups containing each 3 elements are called \b tuples.\n \b Number \b of \b values \b stored \b in \b an \b array \b is \b equal \b to \b number \b of \b tuples
  \b multiplied \b by \b number \b of \b components. \n
  Generally speaking, except for vector field arrays, and array for nodes coordinates, the number of components is equal to one.

- The fourth thing is linked to point 2 and 3 as MEDCoupling is developped in C++ the values of arrays are stored tuples by tuples, that is to say in full interlace mode.\n
  That is to say, the 15 values in the example in point 3 will be stored like this :\n
  \f$ x_0,y_0,z_0,x_1,y_1,z_1,x_2,y_2,z_2,x_3,y_3,z_3,x_4,y_4,z_4 \f$ where x stands for component #0, y for component #1 and z for component #2
  As consequence \b all \b algorithms \b in \b ParaMEDMEM \b are \b working \b in \b full \b interlace \b mode. 

- The fifth thing is that each components of an array has info stored in a string. If a unit is desired to be added on components the following convention should be used "MY_COMPO_INFO [MYUNIT]".\n
  Unit should be put between "[" and "]" after info and one space character.

- The sixth thing is that MEDCoupling arrays inherits from \ref ParaMEDMEM::TimeLabel "TimeLabel" class. It means that the time stamp attached to array indicates if yes or no the array has been modified.
  In C++ if the access of data is direct using non const \c getPointer method it is the reponsability to the use to notify the possible modification.
  Inversely if setIJ method is used to modify an array, take care of the fact that the time stamp of the array is modified on each call to setIJ. If huge amount of call to setIJ is required it
  is better to use setIJSilent instead and call notifyNew right after instead.
  

\section MEDCouplingArraySteps0 Building an array from scratch in Python

\verbatim
arrayDouble=DataArrayDouble.New();
dataDouble=[0.,10.,20.,1.,11.,21.,2.,12.,22.,3.,13.,23.,4.,14.,24.]
arrayDouble.setValues(dataDouble,5,3);# 5 tuples containing each 3 components
#####
arrayInt=DataArrayInt.New();
dataInt=[0, 10, 20, 1, 11, 21, 2, 12, 22, 3, 13, 23, 4, 14, 24]
arrayInt.setValues(dataInt,5,3);# 5 tuples containing each 3 components
\endverbatim

\section MEDCouplingArraySteps1 Building an array from scratch in C++

All of exemples given here make the assumption that the \c ParaMEDMEM
namespace is visible ( by calling for example \c using \c
namespace \c ParaMEDMEM; ).

Here a description of typical usages to use \ref ParaMEDMEM::DataArrayDouble "MEDCoupling arrays".\n
In this example we will create arrays with 12 tuples constituted each
of 3 components. These arrays will be created using different ways.\n

The following code is only based using \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble"
but the use of \ref ParaMEDMEM::DataArrayInt "DataArrayInt" is strictly equivalent.

\code

const int nbOfNodes=12;
double coords[3*nbOfNodes]={ ... };

DataArrayDouble *myCoords=0;
double *tmp=0;
\endcode

- no copy no ownership
\code
myCoords=DataArrayDouble::New();
myCoords->useArray(coords,false,CPP_DEALLOC,nbOfNodes,3);
//now use myCoords as you need
...
//myCoords is no more usefully here : release it
myCoords->decrRef();
\endcode


- no copy and ownership C++
\code
myCoords=DataArrayDouble::New();
tmp=new double[3*nbOfNodes];
std::copy(coords,coords+3*nbOfNodes,tmp);
myCoords->useArray(tmp,true,CPP_DEALLOC,nbOfNodes,3);
//now use myCoords as you need
...
//myCoords is no more usefully, release it
myCoords->decrRef();
\endcode

- no copy and ownership C
\code
myCoords=DataArrayDouble::New();
tmp=(double *)malloc(3*nbOfNodes*sizeof(double));
std::copy(coords,coords+3*nbOfNodes,tmp);
myCoords->useArray(tmp,true,C_DEALLOC,nbOfNodes,3);
//now use myCoords as you need
...
//myCoords is no more usefully here : release it
myCoords->decrRef();
\endcode

- copy
\code
myCoords=DataArrayDouble::New();
myCoords->alloc(nbOfNodes,3);
tmp=myCoords->getPointer();
std::copy(coords,coords+3*nbOfNodes,tmp);
myCoords->declareAsNew();//you have modified data pointed by internal pointer notify object
//now use myCoords as you need
...
//myCoords is no more usefully here : release it
myCoords->decrRef();
\endcode

\section MEDCouplingArrayRenumbering Array renumbering

Here is presented all it is necessary to know concerning renumbering.
Renumbering is intensely required in %MEDLoader in %ParaMEDMEM. One of the user of renumbering is MED file for I/O where cells are sorted by type.
But it is also used on operations of node cell merging. It is also used in parallel mode when splitting of mesh is needed...

Formally a renumbering is a mathematical application that can be surjective, injective or bijective. This application is defined using an instance of
\ref ParaMEDMEM::DataArrayInt "DataArrayInt". There are different ways to define this application.

\subsection MEDCouplingArrayRenumberingO2N Old to new mode

The old to new mode is particulary recommanded for surjective and bijective application. This is typically the case of \ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "MEDCouplingUMesh::mergeNodes" method.
Let's consider a call to \ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "mergeNodes" that reduces the number of nodes from 5 nodes to 3 nodes.\n
In old to new mode the array \b MySurjection that specifies this surjection will have 5 tuples and 1 component. The content of the 5*1 values will be in {0,1,2}.\n

If \b MySujection equals [2,1,0,1,2], it means that :

- old id #0 will have new id equal to 2
- old id #1 will have new id equal to 1
- old id #2 will have new id equal to 0
- old id #3 will have new id equal to 1 like old id #1
- old id #4 will have new id equal to 2 like old id #0

This is the most common mode of renumbering in MEDCoupling because there is more methods implying renumbering that reduce the number of entities than method that increase number of entities.

Method in old to new mode that works on bijective applications :

- \ref ParaMEDMEM::DataArrayDouble::renumber "DataArrayDouble::renumber"
- \ref ParaMEDMEM::DataArrayDouble::renumberInPlace "DataArrayDouble::renumberInPlace"

Method in old to new mode that works on surjective applications :

- \ref ParaMEDMEM::DataArrayDouble::renumberAndReduce "DataArrayDouble::renumberAndReduce"

Sometimes the format old to new for sujections can be replaced by another format with 2 arrays. Less compact in memory. The \ref ParaMEDMEM::DataArrayInt::changeSurjectiveFormat "DataArrayInt::changeSurjectiveFormat" method performs that.

\subsection MEDCouplingArrayRenumberingN2O New to old mode

The new to old mode is particulary recommanded for strictly injective and bijective permutations. This is particulary usefull for methods that increase the number of entities like for example
\ref ParaMEDMEM::MEDCouplingUMesh::simplexize "MEDCouplingUMesh::simplexize".\n
All non static methods in \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" or \ref ParaMEDMEM::DataArrayInt "DataArrayInt" having as last letter \b R (meaning Reversed) in capital works with
the mode new to old.
Let's consider a call to \ref ParaMEDMEM::MEDCouplingUMesh::simplexize "simplexize" that increases the number of cell from 4 cells to 6 cells.\n
In new to old mode the array \b MyInjection that specifies this injection will have 6 tuples and 1 component. The content of the 5*1 values will be in {0,1,2,3}.\n
If \b MyInjection equals [2,0,1,1,3,0] it means that :

- new id #0 comes from old id 2
- new id #1 comes from old id 0
- new id #2 comes from old id 1
- new id #3 comes from old id 1
- new id #4 comes from old id 3
- new id #5 comes from old id 0

Method in new to old mode that works on bijective applications :

- \ref ParaMEDMEM::DataArrayDouble::renumberR "DataArrayDouble::renumberR"
- \ref ParaMEDMEM::DataArrayDouble::renumberInPlace "DataArrayDouble::renumberInPlaceR"

Method in new to old mode that works on surjective applications :

- \ref ParaMEDMEM::DataArrayDouble::selectByTupleId "DataArrayDouble::selectByTupleId"

*/

/*!
    \defgroup NatureOfField Nature of a field

    \section  IntExtFields Overview: intensive and extensive field

\c NatureOfField is an enum which helps determining some physical significance of the field and affects the choice of interpolation formula ( see \ref TableNatureOfField).
It has five possible values:
-      "NoNature", the default value, does not allow the use of interpolation tools
-      "ConservativeVolumic", for intensive field with conservativity favored over the maximum principle
-      "Integral", for extensive field with the maximum principle favored over conservativity
-      "IntegralGlobConstraint", for extensive fields with conservativity favored over the maximum principle
-      "RevIntegral", for intensive field with the maximum principle favored over conservativity

By an intensive field we mean a field that represent volumetric or intensive physical variable such as density (\f$kg.m^{-3}\f$), power density (\f$W.m^{-3}\f$), temperature (\f$K\f$) or pressure (\f$Pa\f$).
By extensive (or integral) field we mean a field that represents an extensive physical quantity sych as mass (\f$kg\f$), volume (\f$m^3\f$), a momentum (\f$kg.m.s^{-1}\f$) or power \f$(W\f$).
For fields with a P0 representation, conservativity formulas are different depending on whether the field is extensive or intensive (see \ref InterpKerP0P0Int and \ref InterpKerP0P0Ext).
In some cases such a non \ref MeshOverlap "overlapping meshes", it is impossible to fulfill both conservation and maximum principle during the interpolation. The nature of the fields determines the formula to be used for non overlapped cells and thus the property that we will be satisfied.
We consider that fields with P1 or P2 representations are necessarily intensive.

\section Usage

In order to employ the various \ref interptools, it is important to specify the nature of your field. 
In case the sources and target meshes do not overlap different treatments will be employed, depending on the nature of the source and target fields.
You can specify the nature of the field when you create a \ref medcoupling field with the following constructor:
\code
MEDCouplingFieldDouble(NatureOfField n, MEDCouplingTimeDiscretization *td, MEDCouplingFieldDiscretization *type);
\endcode

If you read or copy an already existing field, or later after its creation, you may want to change/set its nature.
In order to do so, you can use the function

\code
void setNature(NatureOfField nat);
\endcode

Here is an example

\code
...
const char sourceFileName[]="source.med";
MEDCouplingFieldDouble *sourceField=MEDLoader::ReadFieldCell(sourceFileName,"Source_Mesh",0,"Density",/*iteration*/0,/*order*/0);
const char targetFileName[]="target.med";
MEDCouplingUMesh *med_target_mesh=MEDLoader::ReadUMeshFromFile(targetFileName,"Target_Mesh",0);
//
sourceField->setNature(ConservativeVolumic);
...
\endcode

*/

/*!
  \page MEDCouplingUMeshPage Unstructured meshes in MEDCoupling
	
An unstructured mesh in \ref medcoupling MEDCoupling is defined by :

  - a point clouds where the explicit coordinates of each point must be specified (inherited from \ref MEDCouplingPointSetPage "MEDCouplingPointSet class").
  - nodal connectivity that specifies for each cell, the points in the previous point clouds that constitutes the cell.

As unstructured mesh is dynamically defined enough, this class is also used by MEDCoupling to instanciate degenerated meshes as :

- points cloud only meshes. This type of mesh will have mesh dimension 0.
- abstract meshes containing only one cell that covers a potentially
  infinite space. This abstract mesh is used as support of fields
  containing only one integrated value. This is typically used to
  represent fields used by system code. This type of mesh will have
  mesh dimension equal to -1.

The norm used for cells connectivity of different types, is the same as specified in MED file except
that connectivities are in represented in \b C \b format and \b not \b in \b FORTRAN \b format !

The class that incarnates the described concept is : ParaMEDMEM::MEDCouplingUMesh.
\n This class inherits from ParaMEDMEM::MEDCouplingPointSet abstract class.
\n So \ref MEDCouplingUMeshPage "MEDCouplingUMesh" inherits from all \ref MEDCouplingPointSetPage "point set features".

\section MEDCouplingUMeshStdBuild Standard building of an unstructured mesh  from scratch

The described method here is called standard, because no special knowledge of underneath nodal connectivity is needed here.
This method of building unstructured mesh is easiest but not the most CPU/memory efficient one.

All of exemples given here make the assumption that the \c ParaMEDMEM namespace is visible ( by calling for example \c using \c namespace \c ParaMEDMEM; ).

Here we will create a mesh with spacedim==3 and meshdim==2. \b mesh contains 5 cells (with geometric type INTERP_KERNEL::NORM_TRI3, INTERP_KERNEL::NORM_QUAD4)
and 9 nodes.

You can notice that it is possible to mix cell types as long as the dimension of cell is exactly equal to meshDim to respect \ref MEDCouplingMeshes "this rule".

\subpage medcouplingcppexamplesUmeshStdBuild1 "Here the C++ implementation."

\subpage medcouplingpyexamplesUmeshStdBuild1 "Here the Python implementation."

\section MEDCouplingUMeshAdvBuild Advanced building of an unstructured mesh  from scratch

Here we are going to build the mesh in a more advanced manner. This method expects that the user knows the storage format underlying ParaMEDMEM::MEDCouplingUMesh.

The same mesh than \ref MEDCouplingUMeshStdBuild "in the standard section above" is going to be implemented using advanced method.

\subpage medcouplingcppexamplesUmeshAdvBuild1 "Here the C++ implementation."

\subpage medcouplingpyexamplesUmeshAdvBuild1 "Here the Python implementation."

*/

/*!
  \page MEDCouplingPointSetPage Point set meshes in MEDCoupling

This is a \b non \b instanciable class that implements many algorithm working only on a set of points without any connectivity aspect.
The presence of this class is only for factorization reasons.

The class that incarnates this concept in \ref medcoupling "MEDCoupling" is : \ref ParaMEDMEM::MEDCouplingPointSet.
Instanciable class ParaMEDMEM::MEDCouplingUMesh inherits from ParaMEDMEM::MEDCouplingPointSet.

Some of most important implemented methods by \ref ParaMEDMEM::MEDCouplingPointSet "MEDCouplingPointSet" class are :

- \ref ParaMEDMEM::MEDCouplingPointSet::getSpaceDimension "getSpaceDimension"
- \ref ParaMEDMEM::MEDCouplingPointSet::getNumberOfNodes "getNumberOfNodes"
- \ref ParaMEDMEM::MEDCouplingPointSet::rotate "rotate"
- \ref ParaMEDMEM::MEDCouplingPointSet::translate "translate"
- \ref ParaMEDMEM::MEDCouplingPointSet::scale "scale"
- \ref ParaMEDMEM::MEDCouplingPointSet::findCommonNodes "findCommonNodes"
- \ref ParaMEDMEM::MEDCouplingPointSet::renumberNodes "renumberNodes"
- \ref ParaMEDMEM::MEDCouplingPointSet::getBoundingBox "getBoundingBox"
*/

/*!
  \page MEDCouplingCMeshPage Cartesian meshes in MEDCoupling

A cartesian mesh is a mesh that represents structured mesh whose nodes are arranged along axes of trihedron. To instanciate an object of this
type, only n arrays are needed. In this type of mesh space dimension \b and mesh dimension are equals and the value is n.
The n arrays will have only one component and the values contained in these arrays will be ascendantly sorted.

The class that incarnates the described concept is : ParaMEDMEM::MEDCouplingCMesh.

*/

/*!
  \page MEDCouplingExtrudedPage 3D Extruded meshes in MEDCoupling

An extruded mesh is a mesh also called 2.5 D. It a convolution of 2D
unstructured mesh with 1D unstructured mesh. The problem is that this
type of mesh is not managed by any file format that's why to build an
instance of this mesh you need 3D unstructured mesh and a 2D
unstructured mesh lying on the same coordinates. The advantage of this
structure is that the interpolation time is optimized.

The class that incarnates this concept in MEDCoupling is : \ref ParaMEDMEM::MEDCouplingExtrudedMesh.
*/

/*!
  \page MEDCouplingFieldTemplatesPage Field templates in MEDCoupling

This concept appears in ICOCO API.
field template is the adequate datastructure to perform costly interpolation matrix computation as \ref RemapperClasses "Remapper class" does.
So, a field template can be seen as field without double values. The double values are only used for light matrix vector multiplication.

Concretely a field template is a pair containing :

- a \ref MEDCouplingMeshesPage "mesh"
- a spatial discretization (on cells, on nodes, on gauss points (including localizations, reference elements), )

*/