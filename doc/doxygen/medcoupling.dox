/*!
\page medcoupling MEDCoupling

\section MEDCouplingIntro Introduction

\ref medcoupling "MEDCoupling" is a library (\b libmedcoupling.so or \b medcoupling.dll) fully written in C++ and wrapped to be called in Python too.

\ref medcoupling "MEDCoupling" C++ library implements a data structure which is the result of the following tradeoff :

- Compliant with coupling :
  - Fields definition defined enough to perform well defined interpolation
  - exchangeable through process as well in parallel case in SPMD paradigm ( \ref paramedmem "ParaMEDMEM" ), as in distributed paradigm using CORBA.
- minimize as much as possible the number of prerequisites needed to use it ; So \ref medcoupling "MEDCoupling" only depends on
\ref interpkernel "INTERP_KERNEL library"
- light enough to be agile in order to :
   - maximize the amount of algorithms being applied on it
   - to ease implementation of clients of \ref medcoupling "MEDCoupling".
- large enough to be used for MED file I/O.
- compliant with VTK visualization DataStructure
- integrate HPC constraints (compact structures, limitation of copies and launching of CPU consuming algorithms only when absolutely needed ).
- compliant with ICOCO API

\ref medcoupling "MEDCoupling" implements a set of algorithms linked to the data structure.

\section MEDCouplingMainConc Main Concepts

Here are listed basic concepts present into \ref medcoupling "MEDCoupling".

For beginners in \ref medcoupling "MEDCoupling" world, it is advisable to read the following concepts in the same order than the underlying list.

- \subpage MEDCouplingArrayPage "DataArrays"
- \subpage MEDCouplingMeshesPage "Meshes"
- \subpage MEDCouplingFieldsPage "Fields"
- \subpage MEDCouplingFieldTemplatesPage "Field templates"
- \subpage MEDCouplingTimeLabelPage "Time labels"

*/

/*!
  \page MEDCouplingMeshesPage Meshes in MEDCoupling

\section MEDCouplingMeshes Common concept shared by all type of Meshes in MEDCoupling

A mesh has the following properties :

- name
- **a dimension (called mesh dimension) and only one** (it implies that \b all cells constituting
mesh have the same dimension)
- a space dimension (relative to coordinates)
- a number of nodes
- a number of cells

In MEDCoupling library there is no presence of faces nor edges.

As a mesh has one dimension and only once, that is to say every cells in
mesh have the same dimension called MeshDimension.

For example a mesh with a meshDimension equal to 1, have \b cells of type
NORM_SEG2. Another example, a mesh with a meshDimension equal
to 2, have \b cells of type
NORM_TRI3 and NORM_POLYGON for example.

The class that incarnates the concept described above is :
\ref ParaMEDMEM::MEDCouplingMesh.

\section MEDCouplingMeshesAvailInstan Available instantiable mesh types in MEDCoupling

- \subpage MEDCouplingUMeshPage "Unstructured meshes"
- \subpage MEDCouplingCMeshPage "Cartesian meshes"
- \subpage MEDCouplingExtrudedPage "3D Extruded meshes"

/*!
\page MEDCouplingFieldsPage Fields in MEDCoupling

[TOC]

\section MEDCouplingFields Field concept

A field in MEDCoupling point of view, is a structure that allows to
store a discretization of a physical value on a defined discretized spatial and
possibly temporal support.

The spatial support is a \ref MEDCouplingMeshesPage "mesh".
A field is lying on an entity that will be specified by the spatial
discretization of the field. For example a field on node will lie on
all nodes of its mesh.

A field on cell will lie on all cells of its mesh.

Fields in MEDCoupling follow the two following rules :

- A field will lie on \b ALL entities of its spatial support (\ref MEDCouplingMeshesPage "mesh").
- A field has \b only \b one spatial support (\ref MEDCouplingMeshesPage "mesh") on its temporal support.

The main properties of a field are :

- name
- spatial support which is a \ref MEDCouplingMeshesPage "mesh"
- a \ref MEDCouplingSpatialDisc "spatial discretization"
- a description of intrinsic nature of the values of field (see \ref NatureOfField). This is important for conservative interpolation (see \ref TableNatureOfField).
- a temporal discretization that specifies, if it exists, the time interval on which the field is covering, and how.
- number of components

This definition of field in MEDCoupling allows an instance of field to
know at any point inside its spatial-temporal support the value.

The class that incarnates the concept described above is : \ref ParaMEDMEM::MEDCouplingFieldDouble.

Some of most important implemented methods are :

- \ref ParaMEDMEM::MEDCouplingFieldDouble::getNumberOfComponents "getNumberOfComponents"
- \ref ParaMEDMEM::MEDCouplingFieldDouble::getValueOn "getValueOn"
- \ref ParaMEDMEM::MEDCouplingFieldDouble::applyFunc "applyFunc"
- \ref ParaMEDMEM::MEDCouplingFieldDouble::addFields "cross instances operations"
\section MEDCouplingSpatialDisc Spatial discretization concept

This is the concept that makes the link, independently from temporal
discretization, between the field and its spatial support(\ref MEDCouplingMeshesPage "mesh"). This
concept allows the field to make a check and interpretation of an
array of values given a spatial support (\ref MEDCouplingMeshesPage "mesh").

The abstract class that incarnates the concept is : \ref ParaMEDMEM::MEDCouplingFieldDiscretization.

The most important pure virtual methods are :

- \ref ParaMEDMEM::MEDCouplingFieldDiscretization::getNumberOfTuples "getnumberOfTuples"
- \ref ParaMEDMEM::MEDCouplingFieldDiscretization::getValueOn "getValueOn"
- \ref ParaMEDMEM::MEDCouplingFieldDiscretization::getMeasureField "getMeasureField"

\section MEDCouplingTemporalDisc Temporal discretization concept

This information allows, independently from spatial discretization, to
associate a time interval, if it exists, on which the field will be
defined. This concept is able to give the value at any time of
the definition interval (if any).

The abstract class \ref ParaMEDMEM::MEDCouplingTimeDiscretization
incarnates this described concept.

This classes and its subclasses are responsible in storing the arrays
of the aggregating field.

The most important methods are :

- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::setTime "setTime" and \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getTime "getTime"
- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getArray "getArray" and \ref ParaMEDMEM::MEDCouplingTimeDiscretization::setArray "setArray"
- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getArraysForTime "getArraysForTime"
- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getValueForTime "getValueForTime"

\section MEDCouplingFirstSteps3 Building a field from scratch

Here we will make the assumption that an instance of \c MEDCouplingMesh called \c mesh has been created ( to know more about mesh creation \ref MEDCouplingUMeshStdBuild "click here" ).

\subsection MEDCouplingFirstSteps3OnCellsNoTS  Create a tensor field with 9 components on cells with no time step

\subpage medcouplingcppexamplesFieldDoubleBuild1 "Here the C++ implementation."

\subpage medcouplingpyexamplesFieldDoubleBuild1 "Here the Python implementation."

\subsection MEDCouplingFirstSteps3OnNodesNoTS Create a scalar field on nodes with no time step

\subpage medcouplingcppexamplesFieldDoubleBuild2 "Here the C++ implementation."

\subpage medcouplingpyexamplesFieldDoubleBuild2 "Here the Python implementation."

\subsection MEDCouplingFirstSteps3OnCellsWTS Create a 2 components-vector field on cells with one time step and no interval

\subpage medcouplingcppexamplesFieldDoubleBuild3 "Here the C++ implementation."

\subpage medcouplingpyexamplesFieldDoubleBuild3 "Here the Python implementation."

\subsection MEDCouplingFirstSteps3OnCellsCTI Create a 3 components-vector field on nodes with a time interval where field remains constant on this time interval

\subpage medcouplingcppexamplesFieldDoubleBuild4 "Here the C++ implementation."

\subpage medcouplingpyexamplesFieldDoubleBuild4 "Here the Python implementation."

\section MEDCouplingSecondStep0 Operations on Fields

Here we will make the assumption that an instance of \ref ParaMEDMEM::MEDCouplingMesh "MEDCouplingMesh"
called \c mesh has been created with spaceDim==2.

\subpage medcouplingcppexamplesFieldDoubleBuild5 "Here a C++ example of more advanced use of MEDCouplingFieldDouble instances".

\subpage medcouplingpyexamplesFieldDoubleBuild5 "Here a Python example of more advanced use of MEDCouplingFieldDouble instances".

*/

/*!

\page MEDCouplingArrayPage MEDCoupling Arrays

[TOC]

\section MEDCouplingArrayIntro Introduction

One of the most basic concept mainly used all over MEDCoupling is
MEDCoupling array.

This concept is used all over
\ref medcoupling "MEDCoupling", \ref paramedmem "ParaMEDMEM", \ref medloader "MEDLoader" modules so it should be correctly
handled to play well with \ref MEDCouplingMeshesPage "Meshes" and \ref MEDCouplingFieldsPage "Fields".

\ref ParaMEDMEM::DataArray "DataArrays" are the atomic element of potentially heavy in memory objects in \ref medcoupling "MEDCoupling", \ref paramedmem "ParaMEDMEM" and \ref medloader "MEDLoader".

There are for the moment two types of arrays :
 - double precision float (64 bits) array incarnated by \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble class".
 - signed integer (32 bits) array incarnated by \ref ParaMEDMEM::DataArrayInt "DataArrayInt class".

\ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" and \ref ParaMEDMEM::DataArrayInt "DataArrayInt" classes inherits from
\ref ParaMEDMEM::DataArray "DataArray" \b non \b instanciable \b class that factorizes some common methods of inherited instanciable classes.

In the rest of the documentation \b DataArray will be used for both \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" and \ref ParaMEDMEM::DataArrayInt "DataArrayInt".

\section MEDCouplingArrayBasics Basics concepts of the DataArrays.

It will be presented in this section common concept shared by the two classes to \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" and \ref ParaMEDMEM::DataArrayInt "DataArrayInt".

\subsection MEDCouplingArrayBasicsName Name

A \ref ParaMEDMEM::DataArray "DataArray" instance has an attribute **name**.

**name** is particularly useful for \ref ParaMEDMEM::DataArray "DataArray" representing profiles, families, groups, fields in MEDLoader.
But excepted these useful usecases, **name** attribute is often ignored when \ref ParaMEDMEM::DataArray "DataArrays" are aggregated (field array, connectivity, coordinates) in a bigger object.
Whatever the usage of the **name** attribute of \ref ParaMEDMEM::DataArray "DataArrays", all methods in ParaMEDMEM::DataArrayDouble and ParaMEDMEM::DataArrayInt class deal with **name** as they do for components names.

\subsection MEDCouplingArrayBasicsTuplesAndCompo Raw data, tuples and components of DataArrays.

The main goal of \ref ParaMEDMEM::DataArray "DataArray" is to store contiguous vector of atomical elements with same basic datatype (signed integers, double precision...). This vector of atomical elements is called **raw data** of \ref ParaMEDMEM::DataArray "DataArray".

The size of this vector of data is called <em>"number of elements"</em>. So the number of bytes stored by a \ref ParaMEDMEM::DataArray "DataArray" instance, is equal to
the  product of the __number of elements__ * __constant size of DataType__ .

As \ref ParaMEDMEM::DataArray "DataArray" instances are designed to store vector fields, tensor fields, coordinate of nodes, the notion of _components_ has been added.

So, \ref ParaMEDMEM::DataArray "DataArrays" have an additional attribute that is number of components that represent the size of a contiguous set of atomical elements.
The vector of atomical elements stored into \ref ParaMEDMEM::DataArray "DataArrays" are grouped in contiguous memory set of atomical elements having each same size.

The contiguous set of atomical elements is called **tuple**. And each **tuple** stored in raw data, have each a length exactly equal to the number of components of
\ref ParaMEDMEM::DataArray "DataArray" storing it.

Thus :

\f[
 N_{elements}=N_{tuples}*N_{components}.
\f]

\f[
 N_{bytes}=N_{elements}*sizeof(DataType)=N_{tuples}*N_{components}*sizeof(DataType).
\f]

In other words, **raw data** of \ref ParaMEDMEM::DataArray "DataArrays" can be seen as a dense matrix, whose number of components would be the row size and number of tuples
would be the column size. In this point of view of \ref ParaMEDMEM::DataArray "DataArrays" a **tuple** is represented by the corresponding row in the dense matrix.

Typically in the **raw data** of  \ref ParaMEDMEM::DataArray "DataArrays" **number of tuples** is highly bigger than **number of components** !

To finish, raw data is stored tuples by tuples, in another words, in **full interlace mode**, which is the natural storage strategy in C/C++ world.

For example, let's consider a DataArray having 3 components (called *x* for the first component, *y* for the second, and *z* for the third) and composed by 5 tuples.
\n The *raw data* of the DataAarray instance will be organized in momory like that : \f$ x_0,y_0,z_0,x_1,y_1,z_1,x_2,y_2,z_2,x_3,y_3,z_3,x_4,y_4,z_4 \f$.


\subsection MEDCouplingArrayBasicsCompoName Information on components name.

As seen in the sub section above, a \ref ParaMEDMEM::DataArray "DataArray" instance has a defined number of components.

There is an information attached to each of these components constituting the \ref ParaMEDMEM::DataArray "DataArray".

This information is concretely a string of characters that allows, if needed, to give information about the corresponding component.

The format chosen in **MEDCoupling** for information on is "MY_COMPO_INFO [MYUNIT]". If needed, the unit attached to the component
should be put between "[" and "]" after the information of the components after one space character.

\subsection MEDCouplingArrayBasicsTimeLabel DataArrays and TimeLabel.

\ref ParaMEDMEM::DataArray "DataArrays instances" can consume big amount of data in memory so they inherit from \subpage MEDCouplingTimeLabelPage "TimeLabel".
So in C++ it is a good practice to use :
- \c getConstPointer method in readonly access.
- \c getPointer method only if write is needed.

If the user in C++ or Python wants to modify intensively its **big** \ref ParaMEDMEM::DataArray "DataArray" instance **not** using raw data pointer it is better to invoke
\c setIJSilent just after invokation of \c declareAsNew instead of calling \c setIJ method that will increment time label of \ref ParaMEDMEM::DataArray "DataArray" instance
on each call.

\c setIJ method usage should be reduced to little modification sessions.

\section MEDCouplingArraySteps0 Building an array from scratch in Python

\subsection MEDCouplingArraySteps0Double Building an double array from scratch in Python

Let's consider a list of floats \c dataDouble.

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayBuild1_0

The easiest way to build the \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble instance" called \c arrayDouble simply call :

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayBuild1_1bis

An another way is to do that :

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayBuild1_1

\subsection MEDCouplingArraySteps0Int Building an int array from scratch in Python

Let's consider a list of ints \c dataInt.

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayBuild1_2

The easiest way to build the \ref ParaMEDMEM::DataArrayInt "DataArrayInt instance" called \c arrayInt simply call :

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayBuild1_3bis

An another way is to do that :

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayBuild1_3


\section MEDCouplingArraySteps1 Building an array from scratch in C++

Here is a description of typical usages of \ref ParaMEDMEM::DataArrayDouble "MEDCoupling arrays".

In this example we will create arrays with 12 tuples constituted each
of 3 components. These arrays will be created using different ways.\n

The following code is only based using \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble"
but the use of \ref ParaMEDMEM::DataArrayInt "DataArrayInt" is strictly equivalent.

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_0

\subsection MEDCouplingArraySteps1NCNO Building an array from scratch in C++, no copy no ownership

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_1

\subsection MEDCouplingArraySteps1NCWCPPO Building an array from scratch in C++, no copy with C++ ownership

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_2

\subsection MEDCouplingArraySteps1NCWCO Building an array from scratch in C++, no copy with C ownership

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_3

\subsection MEDCouplingArraySteps1WC Building an array from scratch in C++, with copy

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_4

\section MEDCouplingArrayBasicsCopy Copy DataArrays.

As \ref ParaMEDMEM::DataArray "DataArrays" are the atomic entity of potentially big memory objects into \ref medcoupling "MEDCoupling"
, \ref ParaMEDMEM::DataArray "DataArrays" introduces concepts of copy and comparison that will be used by aggregating classes.

For more complex objects (that aggregate themselves big objects)
like ParaMEDMEM::MEDCouplingFieldDouble the concept of copy (shallow or deep) is less straight forward because which aggregated subobjects are copied or not.

\subsection MEDCouplingArrayBasicsCopyDeep Deep copy of DataArray

As for all potentially heavy memory consumer objects in \ref medcoupling "MEDCoupling", \ref ParaMEDMEM::DataArray "DataArrays" implement
 method \c deepCpy. This method deeply copies an instance. The life cycle of the returned object is *fully* independent from the instance on which the method
\c deepCpy has been invoked.

To perform a deep copy of a DataArray instance simply invoke :

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_5

or :

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_5bis

\c myCoordsCpy is the deep copy of \c myCoords so they are independent and their *raw data* has been deeply copied.

So it leads to the following behaviour :
\anchor MEDCouplingArrayBasicsCopyDeepTestEqual

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_6

As \c myCoordsCpy is a copy object it needs to be deallocated in C++ like \c myCoords.

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_7

\subsection MEDCouplingArrayBasicsCopyShallow Shallow copy of DataArray

As \ref ParaMEDMEM::DataArray "DataArrays" are the atomic entity of potentially big memory objects into \ref medcoupling "MEDCoupling", the shallow copy
simply returns the same object with the reference counter incremented.

To perform a shallow copy of a DataArray instance simply invoke :

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_8

\c myCoordsCpy is the shallow copy of \c myCoords so they share the same *raw data*. In reality they are the same object.
So it leads to the following behaviour to compare with the deep copy :

\anchor MEDCouplingArrayBasicsCopyShallowTestEqual

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_9

So here the content of \c myCoords and \c myCoordsCpy are linked, contrary to the deep copy case.

As \c myCoordsCpy is a copy object, in C++, it needs to be deallocated.

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_10

\subsection MEDCouplingArrayBasicsCopyDeepAssign Assignation by deep copy of DataArray

We start by building a instance of ParaMEDMEM::DataArrayDouble allocated or not. Here, instance is not allocated, only built empty.

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_11

Then, \c myCoordsCpy is assigned with the content of \c myCoords.

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_12

Then \c myCoordsCpy is a deep copy of \c myCoords except that the instance of ParaMEDMEM::DataArrayDouble is those specified.
But the behaviour is the same than those seen for \ref MEDCouplingArrayBasicsCopyDeepTestEqual "deep copy".

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_13

As always, in C++, \c myCoordsCpy is an object whose life cycle is fully independent from \c myCoords so decrement is needed.

\snippet MEDCouplingExamplesTest.cxx CppSnippetDataArrayBuild1_14

\section MEDCouplingArrayBasicsCompare Compare DataArrays.

Comparison is \ref medcoupling "MEDCoupling" is a concept highly sensitive because big amount of tests uses this to state about the sucess or the fail of these tests.
There are two types of comparison :

- strict, that compares strictly all the non mutable attributes (state sensitive). Methods to perform this strict comparison are :
  - ParaMEDMEM::DataArrayInt::isEqual
  - ParaMEDMEM::DataArrayDouble::isEqual.

- less strict, that focus only on non string attributes. Methods to perform less strict comparison are :
  - ParaMEDMEM::DataArrayInt::isEqualWithoutConsideringStr
  - ParaMEDMEM::DataArrayDouble::isEqualWithoutConsideringStr

\section MEDCouplingArrayFill Filling DataArray with values

Both DataArrayDouble and DataArrayInt provide comfort methods that
fill the array with some values. These methods are:
- ParaMEDMEM::DataArrayInt::fillWithZero and
  ParaMEDMEM::DataArrayDouble::fillWithZero which assigns zero to all
  values in array.
- ParaMEDMEM::DataArrayInt::fillWithValue and
  ParaMEDMEM::DataArrayDouble::fillWithValue which assigns a certain value to all
  values in array.
- ParaMEDMEM::DataArrayInt::iota() and
  ParaMEDMEM::DataArrayDouble::iota() which assigns incrementing values to all
  values in array.

\section MEDCouplingArrayRenumbering Array renumbering

Here is presented all it is necessary to know concerning renumbering.
Renumbering is intensely required in %MEDLoader in %ParaMEDMEM. One of the user of renumbering is MED file for I/O where cells are sorted by type.
But it is also used on operations of node cell merging. It is also used in parallel mode when splitting of mesh is needed...

Formally a renumbering is a mathematical application that can be surjective, injective or bijective. This application is defined using an instance of
\ref ParaMEDMEM::DataArrayInt "DataArrayInt". There are different ways to define this application.

\subsection MEDCouplingArrayRenumberingO2N Old to new mode

The old to new mode is particularly recommended for surjective and bijective application. This is typically the case of \ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "MEDCouplingUMesh::mergeNodes" method.
Let's consider a call to \ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "mergeNodes" that reduces the number of nodes from 5 nodes to 3 nodes.\n
In old to new mode the array \b MySurjection that specifies this surjection will have 5 tuples and 1 component. The content of the 5*1 values will be in {0,1,2}.\n

If \b MySujection equals [2,1,0,1,2], it means that :

- old id #0 will have new id equal to 2
- old id #1 will have new id equal to 1
- old id #2 will have new id equal to 0
- old id #3 will have new id equal to 1 like old id #1
- old id #4 will have new id equal to 2 like old id #0

This is the most common mode of renumbering in MEDCoupling because there is more methods implying renumbering that reduce the number of entities than method that increase number of entities.

Method in old to new mode that works on bijective applications :

- \ref ParaMEDMEM::DataArrayDouble::renumber "DataArrayDouble::renumber"
- \ref ParaMEDMEM::DataArrayDouble::renumberInPlace "DataArrayDouble::renumberInPlace"

Method in old to new mode that works on surjective applications :

- \ref ParaMEDMEM::DataArrayDouble::renumberAndReduce "DataArrayDouble::renumberAndReduce"

Sometimes the format old to new for surjections can be replaced by another format with 2 arrays. Less compact in memory. The \ref ParaMEDMEM::DataArrayInt::changeSurjectiveFormat "DataArrayInt::changeSurjectiveFormat" method performs that.

\subsection MEDCouplingArrayRenumberingN2O New to old mode

The new to old mode is particularly recommended for strictly injective and bijective permutations. This is particularly useful for methods that increase the number of entities like for example
\ref ParaMEDMEM::MEDCouplingUMesh::simplexize "MEDCouplingUMesh::simplexize".\n
All non static methods in \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" or \ref ParaMEDMEM::DataArrayInt "DataArrayInt" having as last letter \b R (meaning Reversed) in capital works with
the mode new to old.
Let's consider a call to \ref ParaMEDMEM::MEDCouplingUMesh::simplexize "simplexize" that increases the number of cell from 4 cells to 6 cells.\n
In new to old mode the array \b MyInjection that specifies this injection will have 6 tuples and 1 component. The content of the 5*1 values will be in {0,1,2,3}.\n
If \b MyInjection equals [2,0,1,1,3,0] it means that :

- new id #0 comes from old id 2
- new id #1 comes from old id 0
- new id #2 comes from old id 1
- new id #3 comes from old id 1
- new id #4 comes from old id 3
- new id #5 comes from old id 0

Method in new to old mode that works on bijective applications :

- \ref ParaMEDMEM::DataArrayDouble::renumberR "DataArrayDouble::renumberR"
- \ref ParaMEDMEM::DataArrayDouble::renumberInPlace "DataArrayDouble::renumberInPlaceR"

Method in new to old mode that works on surjective applications :

- \ref ParaMEDMEM::DataArrayDouble::selectByTupleId "DataArrayDouble::selectByTupleId"
- \ref ParaMEDMEM::DataArrayDouble::selectByTupleIdSafe "DataArrayDouble::selectByTupleIdSafe"
- \ref ParaMEDMEM::DataArrayDouble::selectByTupleId2 "DataArrayDouble::selectByTupleId2"
- \ref ParaMEDMEM::DataArrayDouble::selectByTupleRanges "DataArrayDouble::selectByTupleRanges"

\section MEDCouplingArrayApplyFunc Application of a function on DataArrayDouble instances.

This section is only dedicated for \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble instances".

It is possible to apply to \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble instance" a function given by a string.

There are different API for applyFunc* methods of \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble class".

\subsection MEDCouplingArrayApplyFuncExpr Expressions supported

In order to reduce as much as possible dependencies, a little dynamic formula interpretor has been developed into INTERP_KERNEL.
This dynamic expression evaluator can deal the following exhaustive list :

- +,-,*,^ (^ for exponent 3^2==9)
- sin,cos,tan,sqrt,abs,exp,max,min,ln (neper logarithm), log (neper logarithm), log10 (decimal logarithm),
- >,<
- if

The expression evaluator is also sensitive to the following var pattern : IVec, JVec, KVec, LVec,... ,ZVec

- IVec stands for unitary vector [1,0,0,0,...]
- JVec stands for unitary vector [0,1,0,0,...]
- KVec stands for unitary vector [0,0,1,0,...]
- ...

The dynamic expression evaluator works tuple by tuple through the *raw data* of DataArrayDouble instance.

The principle of the dynamic expression evaluator is the following :

- Given the input string a compilation tree is built whose leaves are either constants or variables.
  At this phase only syntax errors are thrown.
\anchor MEDCouplingArrayApplyFuncExprA1
- Then given the computed tree, a link phase is performed to accelerate evaluation. At this phase the incoherence between the number of
  components and the number of variables are detected.

- The given the preprocessed tree given an input tuple a preallocated tuple is fed with the result of the evaluation.
  At this last phase only mathematical errors are thrown (division by 0, log(0), sqrt of a negative number ...)

\subsection MEDCouplingArrayApplyFunc0 applyFunc method with only one parameter

This method produces a newly allocated DataArrayDouble instance having exactly the same number of components **and** number of tuples than the instance on which the
\ref ParaMEDMEM::DataArrayDouble::applyFunc(const char *) const applyFunc method is applied.

**This method is useful when the evaluation expression do not need to consider the components of each tuple separately**.

That's why this method of \ref ParaMEDMEM::DataArrayDouble::applyFunc(const char *) const applyFunc method with one parameter accepts at most only one variable.

If it is not the case an exception is thrown as seen here :

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayApplyFunc1_1

Let's take a very simple example on a DataArrayDouble instance \c d having 4 tuples and 2 components.

In the next example the expression contains only one variable : \c smth.
So \c smth represent a tuple of size 2.

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayApplyFunc1_2

As the example shows, the output \c d1 has 2 components as \c d.

Whereas all the components of the input of \c d be not considered separately, it is also, possible with \ref ParaMEDMEM::DataArrayDouble::applyFunc(const char *) const applyFunc method with one parameter
to build an output having same number of components than input but where components in input are treated separately.

Let's build an example using DataArrayDouble instance \c d defined just above.

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayApplyFunc1_3

In this example using IVec and JVec it is possible to differentiate output in component #0 and output in component #1 for DataArrayDouble instance \c d2.

\subsection MEDCouplingArrayApplyFunc1 applyFunc method with only two parameters

This method also returns a newly allocated DataArrayDouble instance having the same number of tuples than the DataArrayDouble instance on which \ref ParaMEDMEM::DataArrayDouble::applyFunc(int,const char *) const applyFunc method is called, but the contrary to previous \ref MEDCouplingArrayApplyFunc0 "applyFunc with one parameter version" here the number of components is set by the user.

The big difference with \ref MEDCouplingArrayApplyFunc0 "applyFunc method with one parameter" seen above is that here components of tuples are treated separately.

The method that implements it is \ref ParaMEDMEM::DataArrayDouble::applyFunc(int,const char *) const here.

Here the number of variables appearing in the expression should be equal at most to the number of component of the DataArrayDouble instance on which \ref ParaMEDMEM::DataArrayDouble::applyFunc(int,const char *) const applyFunc method is called.

Let's consider the following DataArrayDouble having 4 tuples with 3 components called dd.

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayApplyFunc1_4

If you intend to create a new DataArrayDouble instance called \c dd1 having only one component that is the result of the sum of first component and the square root of the second component and the third component
the invocation should be something like this :

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayApplyFunc1_5

\warning In the expression \c "f+sqrt(g)+h", there are 3 variables \c {"g","h","f"}. As seen \ref MEDCouplingArrayApplyFuncExprA1 "in link phase in expression evaluator" it is needed to match a variable to
the component id. The strategy of expression evaluator is the following. Sort ascendingly variables using their names and affect component id following this sorted list. It leads to :
- \c f will be attached to component #0 of \c dd
- \c g will be attached to component #1 of \c dd
- \c h will be attached to component #2 of \c dd

Considering the previous warning, let's try to perform an application of function to compute in a DataArrayDouble instance called \c dd2 starting by adding component #0 and component #2
of \c dd.
\nThe expression \c "a+c" will add component #0 to component #1 as seen in warning section !!!! It can appear silly, but this strategy has been chosen in order to support different set of variables.
\n \ref ParaMEDMEM::DataArrayDouble::applyFunc2 "applyFunc2" and \ref ParaMEDMEM::DataArrayDouble::applyFunc3 "applyFunc3" methods have been developed to remedy to that feature that can be surprising.
\n These two methods are explained respectively \ref MEDCouplingArrayApplyFunc2 "here for applyFunc2" and \ref MEDCouplingArrayApplyFunc3 "here for applyFunc3".

Whatever it is possible to find a workaround using \ref ParaMEDMEM::DataArrayDouble::applyFunc(int,const char *) const applyFunc with 2 parameters.
\n Here is a solution to compute \c dd2 :

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayApplyFunc1_6

\subsection MEDCouplingArrayApplyFunc2 applyFunc2 method

The method that implements it is \ref ParaMEDMEM::DataArrayDouble::applyFunc2 here.

This method is very close to \ref MEDCouplingArrayApplyFunc1 "applyFunc method with only two parameters".

The only different is the mapping between variables found in expression and tuple id. Rather than using rank in string sorting as \ref MEDCouplingArrayApplyFunc1 "applyFunc method with only two parameters uses" here the component information are considered.

Let's consider DataArrayDouble instance \c ddd constituted with 4 tuples containing each 3 components. The components are named respectively \c {"Y","AA","GG"} with following different units attached on them.

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayApplyFunc1_7

To compute the sum of the first component (component #0) and the third component (component #2) simply do that :

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayApplyFunc1_8

\subsection MEDCouplingArrayApplyFunc3 applyFunc3 method

The method that implements it is \ref ParaMEDMEM::DataArrayDouble::applyFunc3 here.

This method is very close to \ref MEDCouplingArrayApplyFunc1 "applyFunc method with only two parameters" and \ref MEDCouplingArrayApplyFunc2 "applyFunc2".

The only different is the mapping between variables found in expression and tuple id. Rather than using rank in string sorting as in \ref MEDCouplingArrayApplyFunc1 "applyFunc method with only two parameters uses" or the component information as in \ref MEDCouplingArrayApplyFunc2 "applyFunc2", here an explicit vector is given in input.

Let's consider DataArrayDouble instance \c ddd constituted with 4 tuples containing each 3 components. To add first component (component #0) and the third component (component #2) simply do that :

\snippet MEDCouplingExamplesTest.py PySnippetDataArrayApplyFunc1_9

*/

/*!
    \defgroup NatureOfField Nature of a field

    \section  IntExtFields Overview: intensive and extensive field

\c NatureOfField is an enum which helps determining some physical significance of the field and affects the choice of the interpolation formula (see \ref TableNatureOfField).
It has five possible values:
-      "NoNature", the default value, does not allow the use of any interpolation tools

-      \ref TableNatureOfFieldExampleConservVol "ConservativeVolumic", for intensive field with the maximum principle favored over conservativity. Relevant for temperature, pressure fields.

-      \ref TableNatureOfFieldExampleRevIntegral "RevIntegral", for intensive field with the conservativity favored over maximum principle. Relevant for power density fields.

-      \ref TableNatureOfFieldExampleIntegral "Integral", for extensive field with the maximum principle favored over conservativity. Relevant for power fields.

-      \ref TableNatureOfFieldExampleIntegralGlobConstraint "IntegralGlobConstraint", for extensive fields with conservativity favored over the maximum principle. Relevant for power fields.

The first two correspond to intensive fields, the last two correspond to extensive fields.

By an intensive field we mean a field that represent an intensive physical variable such as density (\f$kg.m^{-3}\f$), power density (\f$W.m^{-3}\f$), temperature (\f$K\f$) or pressure (\f$Pa\f$). Typically the physical value doesn't scale with the size of the underlying geometry.
By extensive (or integral) field we mean a field that represents an extensive physical quantity such as mass (\f$kg\f$), volume (\f$m^3\f$), a momentum (\f$kg.m.s^{-1}\f$) or power \f$(W\f$).
Typically the field value scales linearly with respect to the underlying geometry size.
For fields with a P0 representation (cell based), conservativity formulas are different depending on whether the field is extensive or intensive (see \ref InterpKerP0P0Int and \ref InterpKerP0P0Ext).
Those two notions are themselves split into two sub-categories.
Indeed in some cases (e.g. non \ref MeshOverlap "overlapping meshes"), it is impossible to fulfill both the conservation principle and the maximum principle during the interpolation. The nature of the fields determine the formula to be used for non overlapping cells and thus the property that we will be satisfied.
Finally we consider that fields with P1 or P2 representations are necessarily intensive.

\section Usage

In order to employ the various \ref interptools, you have to specify the nature of your field.
When the source and target meshes do not overlap, different treatments will be employed depending on the nature of the source and target fields.
You can specify the nature of the field when you create a \ref medcoupling field with the following constructor:
\code
MEDCouplingFieldDouble(NatureOfField n, MEDCouplingTimeDiscretization *td, MEDCouplingFieldDiscretization *type);
\endcode

If you read or copy an already existing field, or later after its creation, you may want to change/set its nature.
In order to do so, you can use the function

\code
void setNature(NatureOfField nat);
\endcode

Here is an example

\code
...
const char sourceFileName[]="source.med";
MEDCouplingFieldDouble *sourceField=MEDLoader::ReadFieldCell(sourceFileName,"Source_Mesh",0,"Density",/*iteration*/0,/*order*/0);
const char targetFileName[]="target.med";
MEDCouplingUMesh *med_target_mesh=MEDLoader::ReadUMeshFromFile(targetFileName,"Target_Mesh",0);
//
sourceField->setNature(ConservativeVolumic);
...
\endcode

*/

/*!
  \page MEDCouplingUMeshPage Unstructured meshes in MEDCoupling

[TOC]

An unstructured mesh in \ref medcoupling MEDCoupling is defined by :

  - a point clouds where the explicit coordinates of each point must be specified (inherited from \subpage MEDCouplingPointSetPage "MEDCouplingPointSet class").
  - nodal connectivity that specifies for each cell, the points in the previous point clouds that constitutes the cell.

As unstructured mesh is dynamically defined enough, this class is also used by MEDCoupling to instantiate degenerated meshes as :

- points cloud only meshes. This type of mesh will have mesh dimension 0.
- abstract meshes containing only one cell that covers a potentially
  infinite space. This abstract mesh is used as support of fields
  containing only one integrated value. This is typically used to
  represent fields used by system code. This type of mesh will have
  mesh dimension equal to -1.

The norm used for cells connectivity of different types, is the same as specified in MED file except
that connectivities are in represented in \b C \b format and \b not \b in \b FORTRAN \b format !

The class that incarnates the described concept is : ParaMEDMEM::MEDCouplingUMesh.
\n This class inherits from ParaMEDMEM::MEDCouplingPointSet abstract class.
\n So \ref MEDCouplingUMeshPage "MEDCouplingUMesh" inherits from all \ref MEDCouplingPointSetPage "point set features".

\section MEDCouplingUMeshStdBuild Standard building of an unstructured mesh  from scratch

The described method here is called standard, because no special knowledge of underneath nodal connectivity is needed here.
This method of building unstructured mesh is easiest but not the most CPU/memory efficient one.

All of examples given here make the assumption that the \c ParaMEDMEM namespace is visible ( by calling for example \c using \c namespace \c ParaMEDMEM; ).

Here we will create a mesh with spacedim==3 and meshdim==2. \b mesh contains 5 cells (with geometric type INTERP_KERNEL::NORM_TRI3, INTERP_KERNEL::NORM_QUAD4)
and 9 nodes.

You can notice that it is possible to mix cell types as long as the dimension of cell is exactly equal to meshDim to respect \ref MEDCouplingMeshes "this rule".

\subpage medcouplingcppexamplesUmeshStdBuild1 "Here is the C++ implementation."

\subpage medcouplingpyexamplesUmeshStdBuild1 "Here is the Python implementation."

\section MEDCouplingUMeshNodalConnectivity How MEDCouplingUMesh stores its nodal connectivity

\ref ParaMEDMEM::MEDCouplingUMesh "MEDCouplingUMesh class" stores its nodal connectivity into 2 arrays.

- The first one, the biggest is ParaMEDMEM::MEDCouplingUMesh::_nodal_connectivity.
- The second one, the less big is ParaMEDMEM::MEDCouplingUMesh::_nodal_connectivity_index.

\image html MEDCouplingUMeshConn.png "Nodal connectivity storage into MEDCouplingUMesh class"
\image latex MEDCouplingUMeshConn.eps "Nodal connectivity storage into MEDCouplingUMesh class"

\note The last value of the nodal connectivity index points to an invalid memory place. It is not an error, simply as for standard C++, all ranges
are given in format [\b begin,\b end) where \b begin is included and \b end excluded.

\section MEDCouplingUMeshAdvBuild Advanced building of an unstructured mesh  from scratch

Here we are going to build the mesh in a more advanced manner. This method expects that the user knows the storage format underlying ParaMEDMEM::MEDCouplingUMesh.

The same mesh than \ref MEDCouplingUMeshStdBuild "in the standard section above" is going to be implemented using advanced method.

\subpage medcouplingcppexamplesUmeshAdvBuild1 "Here the C++ implementation."

\subpage medcouplingpyexamplesUmeshAdvBuild1 "Here the Python implementation."

*/

/*!
  \page MEDCouplingPointSetPage Point set meshes in MEDCoupling

This is a \b non \b instantiable class that implements many algorithm working only on a set of points without any connectivity aspect.
The presence of this class is only for factorization reasons.

The class that incarnates this concept in \ref medcoupling "MEDCoupling" is : \ref ParaMEDMEM::MEDCouplingPointSet.
Instantiable class ParaMEDMEM::MEDCouplingUMesh inherits from ParaMEDMEM::MEDCouplingPointSet.

Some of most important implemented methods by \ref ParaMEDMEM::MEDCouplingPointSet "MEDCouplingPointSet" class are :

- \ref ParaMEDMEM::MEDCouplingPointSet::getSpaceDimension "getSpaceDimension"
- \ref ParaMEDMEM::MEDCouplingPointSet::getNumberOfNodes "getNumberOfNodes"
- \ref ParaMEDMEM::MEDCouplingPointSet::rotate "rotate"
- \ref ParaMEDMEM::MEDCouplingPointSet::translate "translate"
- \ref ParaMEDMEM::MEDCouplingPointSet::scale "scale"
- \ref ParaMEDMEM::MEDCouplingPointSet::findCommonNodes "findCommonNodes"
- \ref ParaMEDMEM::MEDCouplingPointSet::renumberNodes "renumberNodes"
- \ref ParaMEDMEM::MEDCouplingPointSet::getBoundingBox "getBoundingBox"
*/

/*!
  \page MEDCouplingCMeshPage Cartesian meshes in MEDCoupling

A cartesian mesh is a mesh that represents structured mesh whose nodes are arranged along axes of trihedron.

To instantiate an object of this type, only n arrays are needed.

In this type of mesh space dimension \b and mesh dimension are equals and the value is n ( with n in [1,2,3] ).

The n arrays will have only one component and the values contained in these arrays will be ascendently sorted.

The class that incarnates the described concept is : ParaMEDMEM::MEDCouplingCMesh.

\section MEDCouplingCMeshStdBuild Standard building of a cartesian mesh from scratch

Let's present an example of a 2D cartesian mesh.

\subpage medcouplingcppexamplesCmeshStdBuild1 "Here the C++ implementation."

\subpage medcouplingpyexamplesCmeshStdBuild1 "Here the Python implementation."

*/

/*!
  \page MEDCouplingExtrudedPage 3D Extruded meshes in MEDCoupling

An extruded mesh is a mesh also called 2.5 D.

It a convolution of 2D unstructured mesh with 1D unstructured mesh.

The problem is that this type of mesh is not managed by any file format that's why to build an instance of this mesh you need 3D unstructured mesh and a 2D
unstructured mesh lying on the same coordinates.

The advantage of this structure is that the interpolation time is highly improved.

This class is also useful for users that want to map the 3D unstructured mesh cell ids level by level along an axe.

The class that incarnates this concept in MEDCoupling is : \ref ParaMEDMEM::MEDCouplingExtrudedMesh.
*/

/*!
  \page MEDCouplingFieldTemplatesPage Field templates in MEDCoupling

This concept appears in ICOCO API.
field template is the adequate data structure to perform costly interpolation matrix computation as \ref RemapperClasses "Remapper class" does.
So, a field template can be seen as field without double values. The double values are only used for light matrix vector multiplication.

Concretely a field template is a pair containing :

- a \ref MEDCouplingMeshesPage "mesh"
- a spatial discretization (on cells, on nodes, on gauss points (including localizations, reference elements), )

*/

/*!
  \page MEDCouplingTimeLabelPage Time label in MEDCoupling

Time label is a **non instanciable** class whose each objects consuming potentially big amount of memory inherit from.
The class that incarnates this concept is ParaMEDMEM::TimeLabel.

Here some of examples of classes that inherit from \ref ParaMEDMEM::TimeLabel "TimeLabel" class :

- ParaMEDMEM::DataArrayInt, ParaMEDMEM::DataArrayDouble
- ParaMEDMEM::MEDCouplingMesh
- ParaMEDMEM::MEDCouplingFieldDouble
- ...

This class is in charge to store a 32 bits unsigned integer called time label, that allows the user to know easily, if an heavy object in memory has been modified or not.

The usage is simple :

- call ParaMEDMEM::TimeLabel::getTimeOfThis a first time to retrieve a reference. Store the returned unsigned integer.
- when you need to know if the instance inheriting from ParaMEDMEM::TimeLabel has changed or not simply invoke ParaMEDMEM::TimeLabel::getTimeOfThis again and compare with the stored value.
  If the value is different, the instance has changed, if not the instance has **not** changed.

The virtual call to ParaMEDMEM::TimeLabel::updateTime change the behaviour of ParaMEDMEM::TimeLabel::getTimeOfThis it is a bug, so please notify the bug into the salome forum.

*/

 LocalWords:  discretization
