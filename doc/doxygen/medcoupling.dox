/*!
\page medcoupling MEDCoupling

\section MEDCouplingIntro Introduction

The MEDCoupling module is presented under the form of a library
libmedcoupling and interfaces. This module MEDCoupling represents the
DataStructure designed to be exchanged by processors as well in
parallel case in SPMD paradigm ( \ref paramedmem "ParaMEDMEM" ), as in
distributed paradigm using CORBA. This DataStructure is \b fully
deconnected from \ref medmem "MEDMEM". This DataStructure is light in
order to minimize as much as possible the number of prerequisites needed
to use it. The idea is that as this DataStructure is intended to be
linked with all of code candidate for coupling ; the number of
prerequisites of medcoupling has to be threfore tiny. MEDCoupling has
been developped to comply with ICOCO API, \ref interpkernel
"conservative interpolators" and VTK visualization
DataStructure. The MEDCoupling DataStructures have been
developped to be compatible with HPC constraints (compact structures,
limitation of copies and launching of CPU consuming algorithms only when
absolutely needed ).

\section MEDCouplingMainBasics Basics

One of the most basic concept mainly used all over MEDCoupling is
MEDCoupling array. This concept is used all over
MEDCoupling/ParaMEDMEM/MEDLoader modules so it should be correctly
handled to play well with \ref MEDCouplingMeshesP "Meshes" and \ref MEDCouplingFieldsP "Fields".

It exists two type of arrays :
 - double precision float array incarnated by ParaMEDMEM::DataArrayDouble class.
 - integer array incarnated by ParaMEDMEM::DataArrayInt class.

To know more about arrays \ref MEDCouplingArrayPage "click here for arrays documentation".

\section MEDCouplingMainConc Main Concepts

- \ref MEDCouplingMeshesP "Meshes"
- \ref MEDCouplingFieldsP "Fields"

\section MEDCouplingFirstSteps2 Building unstructured mesh from scratch

All of exemples given here make the assumption that the \c ParaMEDMEM
namespace is visible ( by calling for example \c using \c
namespace \c ParaMEDMEM; ).

Here we will create a mesh with spacedim==2 and meshdim==2 too with 5
cells and 9 nodes.

You can notice that it is possible to mix cell
types as you want as long as the dimension of cell is exactly equal to
meshDim to respect \ref MEDCouplingMeshes "this rule".

\code

double coords[18]={-0.3,-0.3, 0.2,-0.3, 0.7,-0.3, -0.3,0.2, 0.2,0.2, 0.7,0.2, -0.3,0.7, 0.2,0.7, 0.7,0.7 };
int conn[18]={0,3,4,1, 1,4,2, 4,5,2, 6,7,4,3, 7,8,5,4};
MEDCouplingUMesh *mesh=MEDCouplingUMesh::New();
mesh->setName("My2DMesh");
mesh->setMeshDimension(2);
mesh->allocateCells(5);//You can put more than 5 if you want but not less.
mesh->insertNextCell(INTERP_KERNEL::NORM_QUAD4,4,conn);
mesh->insertNextCell(INTERP_KERNEL::NORM_TRI3,3,conn+4);
mesh->insertNextCell(INTERP_KERNEL::NORM_TRI3,3,conn+7);
mesh->insertNextCell(INTERP_KERNEL::NORM_QUAD4,4,conn+10);
mesh->insertNextCell(INTERP_KERNEL::NORM_QUAD4,4,conn+14);
mesh->finishInsertingCells();
DataArrayDouble *myCoords=DataArrayDouble::New();
myCoords->alloc(9,2);//here myCoords are declared to have 2 components, mesh will deduce that spaceDim==2
std::copy(coords,coords+18,myCoords->getPointer());
mesh->setCoords(myCoords);
myCoords->decrRef();
//mesh is now usable
...
//mesh is no more usefully here : release it
mesh->decrRef();  

\endcode

\section MEDCouplingFirstSteps3 Building a field from scratch

All of exemples given here make the assumption that the \c ParaMEDMEM
namespace is visible ( by calling for example \c using \c
namespace \c ParaMEDMEM; ).

Here we will make the assumption that an instance of \c MEDCouplingMesh
called \c mesh has been created.

- create a tensor field with 9 components on cells with no time step
\code
MEDCouplingFieldDouble* fieldOnCells=MEDCouplingFieldDouble::New(ON_CELLS,NO_TIME);
fieldOnCells->setName("MyTensorFieldOnCellNoTime");
fieldOnCells->setMesh(mesh);
DataArrayDouble *array=DataArrayDouble::New();
array->alloc(mesh->getNumberOfCells(),9);//Implicitely fieldOnCells will be a 9 components field.
fieldOnCells->setArray(array);
tmp=array->getPointer();
std::fill(tmp,tmp+9*mesh->getNumberOfCells(),7.);
array->declareAsNew();
array->decrRef();
//fieldOnCells is now usable
...
//fieldOnCells is no more usefully here : release it
fieldOnCells->decrRef();
\endcode
- create a scalar field on nodes with no time step
\code
MEDCouplingFieldDouble* fieldOnNodes=MEDCouplingFieldDouble::New(ON_NODES,NO_TIME);
fieldOnNodes->setName("MyScalarFieldOnNodeNoTime");
fieldOnNodes->setMesh(mesh);
DataArrayDouble *array=DataArrayDouble::New();
array->alloc(mesh->getNumberOfNodes(),1);//Implicitely fieldOnNodes will be a scalar field.
fieldOnNodes->setArray(array);
tmp=array->getPointer();
std::fill(tmp,tmp+mesh->getNumberOfNodes(),7.);
array->declareAsNew();
array->decrRef();
//fieldOnNodes is now usable
...
//fieldOnNodes is no more usefully here : release it
fieldOnNodes->decrRef();
\endcode
- create a 2 components-vector field on cells with one time step and no interval
\code
MEDCouplingFieldDouble* fieldOnCells=MEDCouplingFieldDouble::New(ON_CELLS,ONE_TIME);
fieldOnCells->setName("MyVecFieldOnCellWithTime");
fieldOnCells->setMesh(mesh);
fieldOnCells->setTime(4.22,2,-1);
DataArrayDouble *array=DataArrayDouble::New();
array->alloc(mesh->getNumberOfCells(),2);//Implicitely fieldOnCells will be a 2 components field.
fieldOnCells->setArray(array);
tmp=array->getPointer();
std::fill(tmp,tmp+2*mesh->getNumberOfCells(),7.);
array->declareAsNew();
array->decrRef();
//fieldOnCells is now usable
...
//fieldOnCells is no more usefully here : release it
fieldOnCells->decrRef();
\endcode
- create a 3 components-vector field on nodes with a time interval where hied is constant
\code
MEDCouplingFieldDouble* fieldOnNodes=MEDCouplingFieldDouble::New(ON_NODES,CONST_ON_TIME_INTERVAL);
fieldOnNodes->setName("MyVecFieldOnNodeWithConstTime");
fieldOnNodes->setMesh(mesh);
fieldOnNodes->setStartTime(4.22,2,-1);
fieldOnNodes->setEndTime(6.44,4,-1);
DataArrayDouble *array=DataArrayDouble::New();
array->alloc(mesh->getNumberOfNodes(),3);//Implicitely fieldOnNodes will be a 3 components field.
fieldOnNodes->setArray(array);
tmp=array->getPointer();
std::fill(tmp,tmp+3*mesh->getNumberOfNodes(),7.);
array->declareAsNew();
array->decrRef();
//fieldOnNodes is now usable
...
//fieldOnNodes is no more usefully here : release it
fieldOnNodes->decrRef();
\endcode

\section MEDCouplingSecondStep0 Operations on Fields
Here we will make the assumption that an instance of \ref ParaMEDMEM::MEDCouplingMesh "MEDCouplingMesh"
called \c mesh has been created with spaceDim==2.
Here some exemple of more advanced use of \ref ParaMEDMEM::MEDCouplingFieldDouble "MEDCouplingFieldDouble".
\code
MEDCouplingFieldDouble *f1=mesh->fillFromAnalytic(ON_NODES,1,"x*x+y*y*3+2.*x");//f1 is scalar
MEDCouplingFieldDouble *f2=mesh->fillFromAnalytic(ON_NODES,1,"cos(x+y/x)");//f2 is scalar too
MEDCouplingFieldDouble *f2bis=mesh->fillFromAnalytic(ON_NODES,2,"x*x*IVec+3*y*JVec");//f2bis is a vectors field
MEDCouplingFieldDouble *f3=(*f1)+(*f2);//f3 scalar
MEDCouplingFieldDouble *f4=(*f3)/(*f2);//f4 scalar
f2bis->applyFunc(1,"sqrt(x*x+y*y)");//f2bis becomes scalar
MEDCouplingFieldDouble *f5=(*f2bis)*(*f4);//f5 scalar
const double pos1[2]={0.25,0.};
double res;
f4->getValueOn(pos1,&res);//f4 is scalar so the returned value is of size 1.
//
...
//f1, f2, f2bis, f3, f4, f5 are no more usefully here : release them
f1->decrRef();
f2->decrRef();
f2bis->decrRef();
f3->decrRef();
f4->decrRef();
f5->decrRef();
\endcode
*/

/*!
  \page MEDCouplingMeshesP Meshes in MEDCoupling

\section MEDCouplingMeshes Common concept shared by all type of Meshes

A mesh has a the following properties :

- name
- a dimension (called mesh dimension) and only one (it implies that \b all cells constituting
mesh have the same dimension)
- a space dimension (relative to coordinates)
- a number of nodes
- a number of cells

In MEDCoupling library there is no presence of faces nor edges.

As a mesh has one dimension and only once, that is to say every cells in
mesh have the same dimension called MeshDimension.

That is to say the
MEDMEM vocabulary of faces and edges \b do \b not \b exist \b anymore here in
MEDCoupling.

For exemple a mesh with a meshDimension equal to 1, have \b cells of type
NORM_SEG2. An another exemple, a mesh with a meshDimension equal
to 2, have \b cells of type
NORM_TRI3 and NORM_POLYGON for example.

The class that incarnates the concept described above is :
\ref ParaMEDMEM::MEDCouplingMesh.

\section MEDCouplingUMeshes Unstructured meshes

An unstructured mesh is defined by :

- a point clouds where the explicit
coordinates of each point must be specified. 
- nodal connectivity that specifies for each cell, the points in the
previous point clouds that constitutes the cell.

As unstructured mesh is dynamically defined enough, this struture is
used by MEDCoupling to instanciate degenerated meshes as :

- points cloud only meshes. This type of mesh will have mesh dimension
  == 0
- abstract meshes containing only one cell that covers a potentially
  infinite space. This abstract mesh is used as support of fields
  containing only one integrated value. This is typically used to
  represent fields used by system code. This type of mesh will have
  mesh dimension equal to -1.

The norm used for cells connectivity of different types, is the same as specified in MED file except
that connectivities are in represented in \b C \b format and \b not \b in
\b FORTRAN \b format !

The class in charge to dealt with the described concept is \ref
ParaMEDMEM::MEDCouplingUMesh. This class inherits
from \ref MEDCouplingPointSets "PointSet" abstract meshes.

\section MEDCouplingPointSets PointSet

This is a \b non \b instanciable class that deals with set of points without
any connectivity aspect.

The class that incarnates this concept in
MEDCoupling is : \ref ParaMEDMEM::MEDCouplingPointSet.

This class is in charge to perform whole or part of algorithms of
its subclasses (\ref
ParaMEDMEM::MEDCouplingUMesh "MEDCouplingUMesh" and \ref
ParaMEDMEM::MEDCouplingUMeshDesc "MEDCouplingUMeshDesc") for
factorization reasons.

Some of most important implemented methods are :

- \ref ParaMEDMEM::MEDCouplingPointSet::getSpaceDimension "getSpaceDimension"
- \ref ParaMEDMEM::MEDCouplingPointSet::getNumberOfNodes "getNumberOfNodes"
- \ref ParaMEDMEM::MEDCouplingPointSet::rotate "rotate"
- \ref ParaMEDMEM::MEDCouplingPointSet::translate "translate"
- \ref ParaMEDMEM::MEDCouplingPointSet::scale "scale"
- \ref ParaMEDMEM::MEDCouplingPointSet::findCommonNodes "findCommonNodes"
- \ref ParaMEDMEM::MEDCouplingPointSet::renumberNodes "renumberNodes"
- \ref ParaMEDMEM::MEDCouplingPointSet::getBoundingBox "getBoundingBox"

\section MEDCouplingCMeshs Cartesian Mesh

A cartesian mesh is a mesh that represents structured mesh whose nodes
are arranged along axes of trihedron. To instanciate an object of this
type, only n arrays are needed. In this type of mesh space dimension
\b and mesh dimension are equals and the value is n. The n arrays will have only one component and the values
contained in these arrays will be ascendantly sorted.

The class that incarnates this concept in MEDCoupling is : \ref ParaMEDMEM::MEDCouplingCMesh.

\section MEDCouplingExtrudedMeshes Extruded Mesh

An extruded mesh is a mesh also called 2.5 D. It a convolution of 2D
unstructured mesh with 1D unstructured mesh. The problem is that this
type of mesh is not managed by any file format that's why to build an
instance of this mesh you need 3D unstructured mesh and a 2D
unstructured mesh lying on the same coordinates. The advantage of this
structure is that the interpolation time is optimized.

The class that incarnates this concept in MEDCoupling is : \ref ParaMEDMEM::MEDCouplingExtrudedMesh.
*/

/*!
\page MEDCouplingFieldsP Fields in MEDCoupling

\section MEDCouplingFields Field concept

A field in MEDCoupling point of view, is a structure that allows to
store a discretization of a physical value on a defined discretized spatial and
possibly temporal support.

The spatial support is a \ref MEDCouplingMeshesP "mesh".
A field is lying on an entity that will be specified by the spatial
discretization of the field. For exemple a field on node will lie on
all nodes of its mesh.

A field on cell will lie on all cells of its mesh.

Fields in MEDCoupling follow the two following rules :

- A field will lie on \b ALL entities of its spatial support (\ref MEDCouplingMeshesP "mesh").
- A field has \b only \b one spatial support (\ref MEDCouplingMeshesP "mesh") on its temporal support.

The main properties of a field are :

- name
- spatial support which is a \ref MEDCouplingMeshesP "mesh"
- a \ref MEDCouplingSpatialDisc "spatial discretization"
- a description of intrinsic nature of the values of field. This is important for conservative interpolation.
- a temporal discretization that specifies, if it exists, the time interval on which the field is covering, and how.
- number of components

This definition of field in MEDCoupling allows an instance of field to
know at any point inside its spatial-temporal support the value.

The class that incarnates the concept described above is : \ref ParaMEDMEM::MEDCouplingFieldDouble.

Some of most important implemented methods are :

- \ref ParaMEDMEM::MEDCouplingFieldDouble::getNumberOfComponents "getNumberOfComponents"
- \ref ParaMEDMEM::MEDCouplingFieldDouble::getValueOn "getValueOn"
- \ref ParaMEDMEM::MEDCouplingFieldDouble::applyFunc "applyFunc"
- \ref ParaMEDMEM::MEDCouplingFieldDouble::addFields "cross instances operations"

\section MEDCouplingSpatialDisc Spatial discretization concept

This is the concept that makes the link, independantly from temporal
discretization, between the field and its spatial support(\ref MEDCouplingMeshesP "mesh"). This
concept allows the field to make a check and interpretation of an
array of values given a spatial support (\ref MEDCouplingMeshesP "mesh").

The abstract class that incarnates the concept is : \ref ParaMEDMEM::MEDCouplingFieldDiscretization.

The most important pure virtual methods are :

- \ref ParaMEDMEM::MEDCouplingFieldDiscretization::getNumberOfTuples "getnumberOfTuples"
- \ref ParaMEDMEM::MEDCouplingFieldDiscretization::getValueOn "getValueOn"
- \ref ParaMEDMEM::MEDCouplingFieldDiscretization::getWeightingField "getWeightingField"

\section MEDCouplingTemporalDisc Temporal discretization concept

This information allows, independantly from spatial discretization, to
associate a time interval, if it exists, on which the field will be
defined. This concept is able to give the value at any time of
the definition interval (if any).

The abstract class \ref ParaMEDMEM::MEDCouplingTimeDiscretization
incarnates this described concept.

This classes and its subclasses are responsible in storing the arrays
of the aggregating field.

The most important methods are :

- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::setTime "setTime" and \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getTime "getTime"
- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getArray "getArray" and \ref ParaMEDMEM::MEDCouplingTimeDiscretization::setArray "setArray"
- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getArraysForTime "getArraysForTime"
- \ref ParaMEDMEM::MEDCouplingTimeDiscretization::getValueForTime "getValueForTime"

*/

/*!
\page MEDCouplingArrayPage MEDCoupling Arrays

\section MEDCouplingArrayIntro Introduction

This page will try to describe data arrays in MEDCoupling. Presently,
in MEDCoupling it exists two types of arrays :

- double precision array incarnated by ParaMEDMEM::DataArrayDouble class.
- signed integer (32 bits) array incarnated by ParaMEDMEM::DataArrayInt class.

\section MEDCouplingArrayBasics Basics concepts

It will be presented in this section common concept shared by the two classes to \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" and \ref ParaMEDMEM::DataArrayInt "DataArrayInt".

- The first thing is that an array has a name (stored as a C++ string). This name is often ignored in MEDCoupling algorithm when arrays are aggregated (field array, connectivity, coordinates).
  The reason is that name is stored by the aggregating object.
  But it can be very usefull for arrays not aggregated in bigger MEDCoupling object for groups ids and families ids for example.

- The second thing is the data storage. For obvious reason, MEDCoupling DataArray stores data in a contiguous way in memory like \c std::vector does.\n

- The third thing is linked to previous point. Data arrays are able to store vectorized data. It is usefull to store the data of a vectorial field. That's why MEDCoupling arrays uses the concepts
  of components. To store an array for a vector field on cell with 3 components lying on a mesh having 5 cells. The array will contain 5*3=15 values grouped by 3.
  The 5 groups containing each 3 elements are called \b tuples.\n \b Number \b of \b values \b stored \b in \b an \b array \b is \b equal \b to \b number \b of \b tuples
  \b multiplied \b by \b number \b of \b components. \n
  Generally speaking, except for vector field arrays, and array for nodes coordinates, the number of components is equal to one.

- The fourth thing is linked to point 2 and 3 as MEDCoupling is developped in C++ the values of arrays are stored tuples by tuples, that is to say in full interlace mode.\n
  That is to say, the 15 values in the example in point 3 will be stored like this :\n
  \f$ x_0,y_0,z_0,x_1,y_1,z_1,x_2,y_2,z_2,x_3,y_3,z_3,x_4,y_4,z_4 \f$ where x stands for component #0, y for component #1 and z for component #2
  As consequence \b all \b algorithms \b in \b ParaMEDMEM \b are \b working \b in \b full \b interlace \b mode. 

- The fifth thing is that each components of an array has info stored in a string. If a unit is desired to be added on components the following convention should be used "MY_COMPO_INFO [MYUNIT]".\n
  Unit should be put between "[" and "]" after info and one space character.

- The sixth thing is that MEDCoupling arrays inherits from \ref ParaMEDMEM::TimeLabel "TimeLabel" class. It means that the time stamp attached to array indicates if yes or no the array has been modified.
  In C++ if the access of data is direct using non const \c getPointer method it is the reponsability to the use to notify the possible modification.
  Inversely if setIJ method is used to modify an array, take care of the fact that the time stamp of the array is modified on each call to setIJ. If huge amount of call to setIJ is required it
  is better to use setIJSilent instead and call notifyNew right after instead.
  

\section MEDCouplingArraySteps0 Building an array from scratch in Python

\verbatim
arrayDouble=DataArrayDouble.New();
dataDouble=[0.,10.,20.,1.,11.,21.,2.,12.,22.,3.,13.,23.,4.,14.,24.]
arrayDouble.setValues(dataDouble,5,3);# 5 tuples containing each 3 components
#####
arrayInt=DataArrayInt.New();
dataInt=[0, 10, 20, 1, 11, 21, 2, 12, 22, 3, 13, 23, 4, 14, 24]
arrayInt.setValues(dataInt,5,3);# 5 tuples containing each 3 components
\endverbatim

\section MEDCouplingArraySteps1 Building an array from scratch in C++

All of exemples given here make the assumption that the \c ParaMEDMEM
namespace is visible ( by calling for example \c using \c
namespace \c ParaMEDMEM; ).

Here a description of typical usages to use \ref ParaMEDMEM::DataArrayDouble "MEDCoupling arrays".\n
In this example we will create arrays with 12 tuples constituted each
of 3 components. These arrays will be created using different ways.\n

The following code is only based using \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble"
but the use of \ref ParaMEDMEM::DataArrayInt "DataArrayInt" is strictly equivalent.

\code

const int nbOfNodes=12;
double coords[3*nbOfNodes]={ ... };

DataArrayDouble *myCoords=0;
double *tmp=0;
\endcode

- no copy no ownership
\code
myCoords=DataArrayDouble::New();
myCoords->useArray(coords,false,CPP_DEALLOC,nbOfNodes,3);
//now use myCoords as you need
...
//myCoords is no more usefully here : release it
myCoords->decrRef();
\endcode


- no copy and ownership C++
\code
myCoords=DataArrayDouble::New();
tmp=new double[3*nbOfNodes];
std::copy(coords,coords+3*nbOfNodes,tmp);
myCoords->useArray(tmp,true,CPP_DEALLOC,nbOfNodes,3);
//now use myCoords as you need
...
//myCoords is no more usefully, release it
myCoords->decrRef();
\endcode

- no copy and ownership C
\code
myCoords=DataArrayDouble::New();
tmp=(double *)malloc(3*nbOfNodes*sizeof(double));
std::copy(coords,coords+3*nbOfNodes,tmp);
myCoords->useArray(tmp,true,C_DEALLOC,nbOfNodes,3);
//now use myCoords as you need
...
//myCoords is no more usefully here : release it
myCoords->decrRef();
\endcode

- copy
\code
myCoords=DataArrayDouble::New();
myCoords->alloc(nbOfNodes,3);
tmp=myCoords->getPointer();
std::copy(coords,coords+3*nbOfNodes,tmp);
myCoords->declareAsNew();//you have modified data pointed by internal pointer notify object
//now use myCoords as you need
...
//myCoords is no more usefully here : release it
myCoords->decrRef();
\endcode

\section MEDCouplingArrayRenumbering Array renumbering

Here is presented all it is necessary to know concerning renumbering.
Renumbering is intensely required in %MEDLoader in %ParaMEDMEM. One of the user of renumbering is MED file for I/O where cells are sorted by type.
But it is also used on operations of node cell merging. It is also used in parallel mode when splitting of mesh is needed...

Formally a renumbering is a mathematical application that can be surjective, injective or bijective. This application is defined using an instance of
\ref ParaMEDMEM::DataArrayInt "DataArrayInt". There are different ways to define this application.

\subsection MEDCouplingArrayRenumberingO2N Old to new mode

The old to new mode is particulary recommanded for surjective and bijective application. This is typically the case of \ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "MEDCouplingUMesh::mergeNodes" method.
Let's consider a call to \ref ParaMEDMEM::MEDCouplingUMesh::mergeNodes "mergeNodes" that reduces the number of nodes from 5 nodes to 3 nodes.\n
In old to new mode the array \b MySurjection that specifies this surjection will have 5 tuples and 1 component. The content of the 5*1 values will be in {0,1,2}.\n

If \b MySujection equals [2,1,0,1,2], it means that :

- old id #0 will have new id equal to 2
- old id #1 will have new id equal to 1
- old id #2 will have new id equal to 0
- old id #3 will have new id equal to 1 like old id #1
- old id #4 will have new id equal to 2 like old id #0

This is the most common mode of renumbering in MEDCoupling because there is more methods implying renumbering that reduce the number of entities than method that increase number of entities.

Method in old to new mode that works on bijective applications :

- \ref ParaMEDMEM::DataArrayDouble::renumber "DataArrayDouble::renumber"
- \ref ParaMEDMEM::DataArrayDouble::renumberInPlace "DataArrayDouble::renumberInPlace"

Method in old to new mode that works on surjective applications :

- \ref ParaMEDMEM::DataArrayDouble::renumberAndReduce "DataArrayDouble::renumberAndReduce"

Sometimes the format old to new for sujections can be replaced by another format with 2 arrays. Less compact in memory. The \ref ParaMEDMEM::DataArrayInt::changeSurjectiveFormat "DataArrayInt::changeSurjectiveFormat" method performs that.

\subsection MEDCouplingArrayRenumberingN2O New to old mode

The new to old mode is particulary recommanded for strictly injective and bijective permutations. This is particulary usefull for methods that increase the number of entities like for example
\ref ParaMEDMEM::MEDCouplingUMesh::simplexize "MEDCouplingUMesh::simplexize".\n
All non static methods in \ref ParaMEDMEM::DataArrayDouble "DataArrayDouble" or \ref ParaMEDMEM::DataArrayInt "DataArrayInt" having as last letter \b R (meaning Reversed) in capital works with
the mode new to old.
Let's consider a call to \ref ParaMEDMEM::MEDCouplingUMesh::simplexize "simplexize" that increases the number of cell from 4 cells to 6 cells.\n
In new to old mode the array \b MyInjection that specifies this injection will have 6 tuples and 1 component. The content of the 5*1 values will be in {0,1,2,3}.\n
If \b MyInjection equals [2,0,1,1,3,0] it means that :

- new id #0 comes from old id 2
- new id #1 comes from old id 0
- new id #2 comes from old id 1
- new id #3 comes from old id 1
- new id #4 comes from old id 3
- new id #5 comes from old id 0

Method in new to old mode that works on bijective applications :

- \ref ParaMEDMEM::DataArrayDouble::renumberR "DataArrayDouble::renumberR"
- \ref ParaMEDMEM::DataArrayDouble::renumberInPlace "DataArrayDouble::renumberInPlaceR"

Method in new to old mode that works on surjective applications :

- \ref ParaMEDMEM::DataArrayDouble::selectByTupleId "DataArrayDouble::selectByTupleId"

*/
